var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>This page contains examples of how to proceed with notetaking and knowledge base with mkdocs syntax</p>"},{"location":"index.html#admonitions","title":"Admonitions","text":"<ul> <li>adds different card laout for notes and warning etc</li> <li>this are proceed with <code>!!!</code> and space and then name of perticular thing</li> </ul> <p>Note</p> <p>Abstract</p> <p>Info</p> <p>Tip</p> <p>Success</p> <p>Question</p> <p>Warning</p> <p>Failure</p> <p>Danger</p> <p>Bug</p> <p>Example</p> <p>Quote</p> <ul> <li>if you want to name the field differently then do this <pre><code>!!! note  \"custom name\"\n    this is custom note\n</code></pre></li> </ul> <p>custom name</p> <p>this is custom note</p> <ul> <li>remove the title <pre><code>!!! note  \"\"\n    this is custom note\n</code></pre></li> </ul> <p>this is custom note</p> <ul> <li>collapsible admonitions <pre><code>??? note\n\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod\n    nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor\n    massa, nec semper lorem quam in massa.\n</code></pre></li> </ul> Note <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"index.html#code-blocks","title":"Code Blocks","text":"<ul> <li>sample code block <pre><code>import tensorflow as tf\n</code></pre></li> <li>code block with title bubble_sort.py<pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre></li> <li>code block with line numbers <pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre></li> <li> <p>code with line highlight <pre><code>def bubble_sort(items):\n    for i in range(len(items)):\n        for j in range(len(items) - 1 - i):\n            if items[j] &gt; items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n</code></pre></p> </li> <li> <p>emmbedding code from source file example.py<pre><code>from dataclasses import dataclasses\nfrom typing import List\n\n@dataclasses\nclass User:\n    id: str\n    name: str\n    age: float\n    weight: float\n    addr: List[str]\n</code></pre></p> </li> <li> <p>content tab</p> </li> </ul> CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>"},{"location":"index.html#tables","title":"tables","text":"Method Description <code>GET</code>      Fetch resource <code>PUT</code>  Update resource <code>DELETE</code>      Delete resource"},{"location":"index.html#formatting","title":"formatting","text":"text with highlight<pre><code>- ==This was marked==\n- ^^This was inserted^^\n- ~~This was deleted~~\n</code></pre> <ul> <li>This was marked</li> <li>This was inserted</li> <li>This was deleted</li> </ul> Text with sub- and superscripts<pre><code>- H~2~O\n- A^T^A\n</code></pre> <ul> <li>H<sub>2</sub>O</li> <li>A<sup>T</sup>A</li> </ul> <p>Keyboard keys<pre><code>++ctrl+alt+del++\n</code></pre> Ctrl+Alt+Del</p>"},{"location":"Ansible/index.html","title":"Welcome to Ansible","text":"<p>This Page contains ansible codes and example along with my own learning journey</p>"},{"location":"Docker/index.html","title":"Welcome to Docker","text":"<p>This section contains knowledge base about docker and podman containers along with container files and compose</p>"},{"location":"Git/index.html","title":"Welcome to git","text":"<ul> <li>this page setup of git very simple propbaly using https</li> <li>some tricks and also some tips</li> </ul>"},{"location":"Git/setting-up.html","title":"Setting up git","text":""},{"location":"Git/setting-up.html#setting-up-with-https","title":"setting up with https","text":"<ul> <li>set user name <code>git config --global user.name \"your_user_name\"</code></li> <li>set email <code>git config --global user.email \"your_email\"</code></li> <li>install library <code>libsecret</code> the library name may change depdending upon linux distribution</li> <li>this will save credentials to gnome-keyring or libsecret <code>git config --global credential.helper /usr/lib/git-core/git-credential-libsecret</code></li> <li>if you can't find this path <code>/usr/lib/git-core/git-credential-libsecret</code> then you can use <code>locate -b git-credential-libsecret</code></li> <li>credentials store with libsecret are encrypted so they are secure</li> </ul> <p>optional</p> <p>you can try https://github.com/hickford/git-credential-oauth this library to authenticate using oauth installation instruction are given in repo.</p>"},{"location":"Git/setting-up.html#setting-up-with-ssh","title":"setting up with ssh","text":"<ul> <li>install <code>openssh</code> package in your system</li> <li>enable service to start on startup for ssh daemon and keygen using <code>sudo systemctl enable --now sshd sshdgenkeys</code></li> <li>run this command to generate keys <code>ssh-keygen -t ed25519 -C \"your_name-git\"</code></li> <li>provide filename to save generally i recommend to use githubusername-git</li> <li>there will be 2 files generated in current directory one public key .pub extension and other without extension that's your private key</li> <li>finally add the ssh key to ssh-agent using <code>ssh-add path-to-files/you_name-git</code> remember always add private key</li> <li>if ssh-agent is not started you can start it by using <code>eval `ssh-agent`</code>and then again follow previous step.</li> <li>now go to github settings \u2192 SSH and GPG Keys \u2192 click on New SSH Key -&gt; put in title, and content of generated key with extension .pub</li> <li>done</li> </ul>"},{"location":"Golang/index.html","title":"Welcome to Golang","text":"<p>This section contains knowledge base for golang, some example and blog post referrals</p>"},{"location":"Golang/common-pitfalls.html","title":"Gotchas and common mistakes","text":"","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#overview","title":"overview","text":"<p>Go is a simple and fun language, but, like any other language, it has a few gotchas... Many of those gotchas are not entirely Go's fault. Some of these mistakes are natural traps if you are coming from another language. Others are due to faulty assumptions and missing details.</p> <p>A lot of these gotchas may seem obvious if you took the time to learn the language reading the official spec, wiki, mailing list discussions, many great posts and presentations by Rob Pike, and the source code. Not everybody starts the same way though and that's OK. If you are new to Go the information here will save you hours debugging your code.</p> <p>you also visit this for more https://github.com/teivah/100-go-mistakes the related book goes here https://www.manning.com/books/100-go-mistakes-and-how-to-avoid-them</p> <p>Total Beginner \u2192</p> <ul> <li>Opening Brace Can't Be Placed on a Separate Line</li> <li>Unused variables</li> <li>Unused imports</li> <li>Short Variable Declarations Can Be Used Only Inside Functions</li> <li>Re-declaring Variables Using Short Variable Declarations</li> <li>Can't Use Short Variable Declarations to Set Field Values</li> <li>Accidental Variable Shadowing</li> <li>Can't Use \"nil\" to Initialize a Variable Without an Explicit Type</li> <li>Using \"nil\" Slices and Maps</li> <li>Map Capacity</li> <li>Strings Can't Be \"nil\"</li> <li>Array Function Arguments</li> <li>Unexpected Values in Slice and Array \"range\" Clauses</li> <li>Slices and Arrays Are One-Dimensional</li> <li>Accessing Non-Existing Map Keys</li> <li>Strings Are Immutable</li> <li>Conversions Between Strings and Byte Slices</li> <li>Strings and Index Operator</li> <li>Strings Are Not Always UTF8 Text</li> <li>String Length</li> <li>Missing Comma In Multi-Line Slice/Array/Map Literals</li> <li>log.Fatal and log.Panic Do More Than Log</li> <li>Built-in Data Structure Operations Are Not Synchronized</li> <li>Iteration Values For Strings in \"range\" Clauses</li> <li>Iterating Through a Map Using a \"for range\" Clause</li> <li>Fallthrough Behavior in \"switch\" Statements</li> <li>Increments and Decrements</li> <li>Bitwise NOT Operator</li> <li>Operator Precedence Differences</li> <li>Unexported Structure Fields Are Not Encoded</li> <li>App Exits With Active Goroutines</li> <li>Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready</li> <li>Sending to an Closed Channel Causes a Panic</li> <li>Using \"nil\" Channels</li> <li>Methods with Value Receivers Can't Change the Original Value</li> </ul> <p>Intermediate Beginner \u2192</p> <ul> <li>Closing HTTP Response Body</li> <li>Closing HTTP Connections</li> <li>JSON Encoder Adds a Newline Character</li> <li>JSON Package Escapes Special HTML Characters in Keys and String Values</li> <li>Unmarshalling JSON Numbers into Interface Values</li> <li>JSON String Values Will Not Be Ok with Hex or Other non-UTF8 Escape Sequences</li> <li>Comparing Structs, Arrays, Slices, and Maps</li> <li>Recovering From a Panic</li> <li>Updating and Referencing Item Values in Slice, Array, and Map \"for range\" Clauses</li> <li>\"Hidden\" Data in Slices</li> <li>Slice Data Corruption</li> <li>\"Stale\" Slices</li> <li>Type Declarations and Methods</li> <li>Breaking Out of \"for switch\" and \"for select\" Code Blocks</li> <li>Iteration Variables and Closures in \"for\" Statements</li> <li>Deferred Function Call Argument Evaluation</li> <li>Deferred Function Call Execution</li> <li>Failed Type Assertions</li> <li>Blocked Goroutines and Resource Leaks</li> <li>Same Address for Different Zero-sized Variables</li> <li>The First Use of iota Doesn't Always Start with Zero</li> </ul> <p>Advanced Beginner \u2192</p> <ul> <li>Using Pointer Receiver Methods On Value Instances</li> <li>Updating Map Value Fields</li> <li>\"nil\" Interfaces and \"nil\" Interfaces Values</li> <li>Stack and Heap Variables</li> <li>GOMAXPROCS, Concurrency, and Parallelism</li> <li>Read and Write Operation Reordering</li> <li>Preemptive Scheduling</li> </ul> <p>Cgo (aka Brave Beginner) \u2192</p> <ul> <li>Import C and Multiline Import Blocks</li> <li>No blank lines Between Import C and Cgo Comments</li> <li>Can't Call C Functions with Variable Arguments</li> </ul>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#opening-brace-cant-be-placed-on-a-separate-line","title":"Opening Brace Can't Be Placed on a Separate Line","text":"<p>\u2192 beginner</p> <p>In most other languages that use braces you get to choose where you place them. Go is different. You can thank automatic semicolon injection (without look ahead) for this behavior. Yes, Go does have semicolons :-)</p> <p>Fails:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main()  \n{ //error, can't have the opening brace on a separate line\n    fmt.Println(\"hello there!\")\n}\n</code></pre> <p>Compile Error:</p> <p>/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before { </p> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    fmt.Println(\"works!\")\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#unused-variables","title":"Unused Variables","text":"<p>\u2192 beginner</p> <p>If you have an unused variable your code will fail to compile. There's an exception though. You must use variables you declare inside functions, but it's OK if you have unused global variables. It's also OK to have unused function arguments. If you assign a new value to the unused variable your code will still fail to compile. You need to use the variable value somehow to make the compiler happy.</p> <p>Fails:</p> <pre><code>package main\n\nvar gvar int //not an error\n\nfunc main() {  \n    var one int   //error, unused variable\n    two := 2      //error, unused variable\n    var three int //error, even though it's assigned 3 on the next line\n    three = 3\n\n    func(unused string) {\n        fmt.Println(\"Unused arg. No compile error\")\n    }(\"what?\")\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not use**d** </p> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    var one int\n    _ = one\n\n    two := 2 \n    fmt.Println(two)\n\n    var three int \n    three = 3\n    one = three\n\n    var four int\n    four = four\n}\n</code></pre> <p>Another option is to comment out or remove the unused variables :-)</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#unused-imports","title":"Unused Imports","text":"<p>\u2192 beginner</p> <p>Your code will fail to compile if you import a package without using any of its exported functions, interfaces, structures, or variables. If you really need the imported package you can use the blank identifier, <code>_</code>, as its package name to avoid this compilation failure. The blank identifier is used to import packages for their side effects.</p> <p>Fails:</p> <pre><code>import (  \n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {  \n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox627475386/main.go:4: imported and not used: \"fmt\" /tmp/sandbox627475386/main.go:5: imported and not used: \"log\" /tmp/sandbox627475386/main.go:6: imported and not used: \"time\u201d </p> <p>Works:</p> <pre><code>package main\n\nimport (  \n    _ \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nvar _ = log.Println\n\nfunc main() {  \n    _ = time.Now\n}\n</code></pre> <p>Another option is to remove or comment out the unused imports :-) The <code>[goimports](http://godoc.org/golang.org/x/tools/cmd/goimports)</code>  tool can help you with that.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#short-variable-declarations-can-be-used-only-inside-functions","title":"Short Variable Declarations Can Be Used Only Inside Functions","text":"<p>\u2192 beginner</p> <p>Fails:</p> <pre><code>package main\n\nmyvar := 1 //error\n\nfunc main() {  \n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body </p> <p>Works:</p> <pre><code>package main\n\nvar myvar = 1\n\nfunc main() {  \n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#re-declaring-variables-using-short-variable-declarations","title":"Re-declaring Variables Using Short Variable Declarations","text":"<p>\u2192 beginner</p> <p>You can't redeclare a variable in a standalone statement, but it is allowed in multi-variable declarations where at least one new variable is also declared. The redeclared variable has to be in the same block or you'll end up with a shadowed variable.</p> <p>Fails:</p> <pre><code>package main\n\nfunc main() {  \n    one := 0\n    one := 1 //error\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox706333626/main.go:5: no new variables on left side of := </p> <p>Works:</p> <pre><code>package main\n\nfunc main() {  \n    one := 0\n    one, two := 1,2\n\n    one,two = two,one\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#cant-use-short-variable-declarations-to-set-field-values","title":"Can't Use Short Variable Declarations to Set Field Values","text":"<p>\u2192 beginner</p> <p>Fails:</p> <pre><code>package main\n\nimport (  \n  \"fmt\"\n)\n\ntype info struct {  \n  result int\n}\n\nfunc work() (int,error) {  \n    return 13,nil  \n  }\n\nfunc main() {  \n  var data info\n\n  data.result, err := work() //error\n  fmt.Printf(\"info: %+v\\n\",data)\n}\n</code></pre> <p>Compile Errors:</p> <p>prog.go:18: non-name data.result on left side of := </p> <p>Even though there's a ticket to address this gotcha it's unlikely to change because Rob Pike likes it \"as is\" :-) Use temporary variables or pre-declare all your variables and use the standard assignment operator.</p> <p>Works:</p> <pre><code>package main\n\nimport (  \n  \"fmt\"\n)\n\ntype info struct {  \n  result int\n}\n\nfunc work() (int,error) {  \n    return 13,nil  \n  }\n\nfunc main() {  \n  var data info\n\n  var err error\n  data.result, err = work() //ok\n  if err != nil {\n    fmt.Println(err)\n    return\n  }\n\n  fmt.Printf(\"info: %+v\\n\",data) //prints: info: {result:13}\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#accidental-variable-shadowing","title":"Accidental Variable Shadowing","text":"<p>\u2192 beginner</p> <p>The short variable declaration syntax is so convenient (especially for those coming from a dynamic language) that it's easy to treat it like a regular assignment operation. If you make this mistake in a new code block there will be no compiler error, but your app will not do what you expect.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := 1\n    fmt.Println(x)     //prints 1\n    {\n        fmt.Println(x) //prints 1\n        x := 2\n        fmt.Println(x) //prints 2\n    }\n    fmt.Println(x)     //prints 1 (bad if you need 2)\n}\n</code></pre> <p>This is a very common trap even for experienced Go developers. It's easy to make and it could be hard to spot.</p> <p>You can use the <code>[vet](http://godoc.org/golang.org/x/tools/cmd/vet)</code> command to find some of these problems. By default, <code>vet</code> will not perform any shadowed variable checks. Make sure to use the <code>-shadow</code> flag: <code>go tool vet -shadow your_file.go</code></p> <p>Note that the <code>vet</code> command will not report all shadowed variables. Use <code>[go-nyet](https://github.com/barakmich/go-nyet)</code> for more aggressive shadowed variable detection.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#cant-use-nil-to-initialize-a-variable-without-an-explicit-type","title":"Can't Use \"nil\" to Initialize a Variable Without an Explicit Type","text":"<p>\u2192 beginner</p> <p>The \"nil\" identifier can be used as the \"zero value\" for interfaces, functions, pointers, maps, slices, and channels. If you don't specify the variable type the compiler will fail to compile your code because it can't guess the type.</p> <p>Fails:</p> <pre><code>package main\n\nfunc main() {  \n    var x = nil //error\n\n    _ = x\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox188239583/main.go:4: use of untyped nil </p> <p>Works:</p> <pre><code>package main\n\nfunc main() {  \n    var x interface{} = nil\n\n    _ = x\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#using-nil-slices-and-maps","title":"Using \"nil\" Slices and Maps","text":"<p>\u2192 beginner</p> <p>It's OK to add items to a \"nil\" slice, but doing the same with a map will produce a runtime panic. however reading from nil map doesn't panic.</p> <p>Works:</p> <pre><code>package main\n\nfunc main() {  \n    var s []int\n    s = append(s,1)\n}\n</code></pre> <p>Fails:</p> <pre><code>package main\n\nfunc main() {  \n    var m map[string]int\n    m[\"one\"] = 1 //error\n\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#map-capacity","title":"Map Capacity","text":"<p>\u2192 beginner</p> <p>You can specify the map capacity when it's created, but you can't use the <code>cap()</code>function on maps.</p> <p>Fails:</p> <pre><code>package main\n\nfunc main() {  \n    m := make(map[string]int,99)\n    cap(m) //error\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap </p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#strings-cant-be-nil","title":"Strings Can't Be \"nil\"","text":"<p>\u2192 beginner</p> <p>This is a gotcha for developers who are used to assigning \"nil\" identifiers to string variables.</p> <p>Fails:</p> <pre><code>package main\n\nfunc main() {  \n    var x string = nil //error\n\n    if x == nil { //error\n        x = \"default\"\n    }\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil) </p> <p>Works:</p> <pre><code>package main\n\nfunc main() {  \n    var x string //defaults to \"\" (zero value)\n\n    if x == \"\" {\n        x = \"default\"\n    }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#array-function-arguments","title":"Array Function Arguments","text":"<p>\u2192 beginner</p> <p>If you are a C or C++ developer arrays for you are pointers. When you pass arrays to functions the functions reference the same memory location, so they can update the original data. Arrays in Go are values, so when you pass arrays to functions the functions get a copy of the original array data. This can be a problem if you are trying to update the array data.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := [3]int{1,2,3}\n\n    func(arr [3]int) {\n        arr[0] = 7\n        fmt.Println(arr) //prints [7 2 3]\n    }(x)\n\n    fmt.Println(x) //prints [1 2 3] (not ok if you need [7 2 3])\n}\n</code></pre> <p>If you need to update the original array data use array pointer types.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := [3]int{1,2,3}\n\n    func(arr *[3]int) {\n        (*arr)[0] = 7\n        fmt.Println(arr) //prints &amp;[7 2 3]\n    }(&amp;x)\n\n    fmt.Println(x) //prints [7 2 3]\n}\n</code></pre> <p>Another option is to use slices. Even though your function gets a copy of the slice variable it still references the original data.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := []int{1,2,3}\n\n    func(arr []int) {\n        arr[0] = 7\n        fmt.Println(arr) //prints [7 2 3]\n    }(x)\n\n    fmt.Println(x) //prints [7 2 3]\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#unexpected-values-in-slice-and-array-range-clauses","title":"Unexpected Values in Slice and Array \"range\" Clauses","text":"<p>\u2192 beginner</p> <p>This can happen if you are used to the \"for-in\" or \"foreach\" statements in other languages. The \"range\" clause in Go is different. It generates two values: the first value is the item index while the second value is the item data.</p> <p>Bad:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := []string{\"a\",\"b\",\"c\"}\n\n    for v := range x {\n        fmt.Println(v) //prints 0, 1, 2\n    }\n}\n</code></pre> <p>Good:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := []string{\"a\",\"b\",\"c\"}\n\n    for _, v := range x {\n        fmt.Println(v) //prints a, b, c\n    }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#slices-and-arrays-are-one-dimensional","title":"Slices and Arrays Are One-Dimensional","text":"<p>\u2192 beginner</p> <p>It may seem like Go supports multi-dimensional arrays and slices, but it doesn't. Creating arrays of arrays or slices of slices is possible though. For numerical computation apps that rely on dynamic multi-dimensional arrays it's far from ideal in terms of performance and complexity.</p> <p>You can build dynamic multi-dimensional arrays using raw one-dimensional arrays, slices of \"independent\" slices, and slices of \"shared data\" slices.</p> <p>If you are using raw one-dimensional arrays you are responsible for indexing, bounds checking, and memory reallocations when the arrays need to grow.</p> <p>Creating a dynamic multi-dimensional array using slices of \"independent\" slices is a two step process. First, you have to create the outer slice. Then, you have to allocate each inner slice. The inner slices are independent of each other. You can grow and shrink them without affecting other inner slices.</p> <pre><code>package main\n\nfunc main() {\n    x := 2\n    y := 4\n\n    table := make([][]int,x)\n    for i:= range table {\n        table[i] = make([]int,y)\n    }\n}\n</code></pre> <p>Creating a dynamic multi-dimensional array using slices of \"shared data\" slices is a three step process. First, you have to create the data \"container\" slice that will hold raw data. Then, you create the outer slice. Finally, you initialize each inner slice by re-slicing the raw data slice.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    h, w := 2, 4\n\n    raw := make([]int,h*w)\n    for i := range raw {\n        raw[i] = i\n    }\n    fmt.Println(raw,&amp;raw[4])\n    //prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;\n\n    table := make([][]int,h)\n    for i:= range table {\n        table[i] = raw[i*w:i*w + w]\n    }\n\n    fmt.Println(table,&amp;table[1][0])\n    //prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt;\n}\n</code></pre> <p>There's a spec/proposal for multi-dimensional arrays and slices, but it looks like it's a low priority feature at this point in time.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#accessing-non-existing-map-keys","title":"Accessing Non-Existing Map Keys","text":"<p>\u2192 beginner</p> <p>This is a gotcha for developers who expect to get \"nil\" identifiers (like it's done in other languages). The returned value will be \"nil\" if the \"zero value\" for the corresponding data type is \"nil\", but it'll be different for other data types. Checking for the appropriate \"zero value\" can be used to determine if the map record exists, but it's not always reliable (e.g., what do you do if you have a map of booleans where the \"zero value\" is false). The most reliable way to know if a given map record exists is to check the second value returned by the map access operation.</p> <p>Bad:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := map[string]string{\"one\":\"a\",\"two\":\"\",\"three\":\"c\"}\n\n    if v := x[\"two\"]; v == \"\" { //incorrect\n        fmt.Println(\"no entry\")\n    }\n}\n</code></pre> <p>Good:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := map[string]string{\"one\":\"a\",\"two\":\"\",\"three\":\"c\"}\n\n    if _,ok := x[\"two\"]; !ok {\n        fmt.Println(\"no entry\")\n    }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#strings-are-immutable","title":"Strings Are Immutable","text":"<p>\u2192 beginner</p> <p>Trying to update an individual character in a string variable using the index operator will result in a failure. Strings are read-only byte slices (with a few extra properties). If you do need to update a string then use a byte slice instead converting it to a string type when necessary.</p> <p>Fails:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := \"text\"\n    x[0] = 'T'\n\n    fmt.Println(x)\n}\n</code></pre> <p>Compile Error:</p> <p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0] </p> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := \"text\"\n    xbytes := []byte(x)\n    xbytes[0] = 'T'\n\n    fmt.Println(string(xbytes)) //prints Text\n}\n</code></pre> <p>Note that this isn't really the right way to update characters in a text string because a given character could be stored in multiple bytes. If you do need to make updates to a text string convert it to a rune slice first. Even with rune slices a single character might span multiple runes, which can happen if you have characters with grave accent, for example. This complicated and ambiguous nature of \"characters\" is the reason why Go strings are represented as byte sequences.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#conversions-between-strings-and-byte-slices","title":"Conversions Between Strings and Byte Slices","text":"<p>\u2192 beginner</p> <p>When you convert a string to a byte slice (and vice versa) you get a complete copy of the orginal data. It's not like a cast operation in other languages and it's not like reslicing where the new slice variable points to the same underlying array used by the original byte slice.</p> <p>Go does have a couple of optimizations for <code>[]byte</code> to <code>string</code> and <code>string</code> to <code>[]byte</code> conversions to avoid extra allocations (with more optimizations on the todo list).</p> <p>The first optimization avoids extra allocations when <code>[]byte</code> keys are used to lookup entries in <code>map[string]</code> collections: <code>m[string(key)]</code>.</p> <p>The second optimization avoids extra allocations in <code>for range</code> clauses where strings are converted to <code>[]byte</code>: <code>for i,v := range []byte(str) {...}</code>.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#strings-and-index-operator","title":"Strings and Index Operator","text":"<p>\u2192 beginner</p> <p>The index operator on a string returns a byte value, not a character (like it's done in other languages).</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    x := \"text\"\n    fmt.Println(x[0]) //print 116\n    fmt.Printf(\"%T\",x[0]) //prints uint8\n}\n</code></pre> <p>If you need to access specific string \"characters\" (unicode code points/runes) use the <code>for range</code>clause. The official \"unicode/utf8\" package and the experimental utf8string package (golang.org/x/exp/utf8string) are also useful. The utf8string package includes a convenient <code>At()</code>method. Converting the string to a slice of runes is an option too.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#strings-are-not-always-utf8-text","title":"Strings Are Not Always UTF8 Text","text":"<p>\u2192 beginner</p> <p>String values are not required to be UTF8 text. They can contain arbitrary bytes. The only time strings are UTF8 is when string literals are used. Even then they can include other data using escape sequences.</p> <p>To know if you have a UTF8 text string use the <code>ValidString()</code> function from the \"unicode/utf8\" package.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {  \n    data1 := \"ABC\"\n    fmt.Println(utf8.ValidString(data1)) //prints: true\n\n    data2 := \"A\\xfeC\"\n    fmt.Println(utf8.ValidString(data2)) //prints: false\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#string-length","title":"String Length","text":"<p>\u2192 beginner</p> <p>Let's say you are a python developer and you have the following piece of code:</p> <pre><code>data = u'\u2665'  \nprint(len(data)) #prints: 1\n</code></pre> <p>When you convert it to a similar Go code snippet you might be surprised.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    data := \"\u2665\"\n    fmt.Println(len(data)) //prints: 3\n}\n</code></pre> <p>The built-in <code>len()</code> function returns the number of bytes instead of the number of characters like it's done for unicode strings in Python.</p> <p>To get the same results in Go use the <code>RuneCountInString()</code> function from the \"unicode/utf8\" package.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {  \n    data := \"\u2665\"\n    fmt.Println(utf8.RuneCountInString(data)) //prints: 1\n}\n</code></pre> <p>Technically the <code>RuneCountInString()</code>function doesn't return the number of characters because a single character may span multiple runes.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {  \n    data := \"e\u0301\"\n    fmt.Println(len(data))                    //prints: 3\n    fmt.Println(utf8.RuneCountInString(data)) //prints: 2\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#missing-comma-in-multi-line-slice-array-and-map-literals","title":"Missing Comma In Multi-Line Slice, Array, and Map Literals","text":"<p>\u2192 beginner</p> <p>Fails:</p> <pre><code>package main\n\nfunc main() {\n    x := []int{\n    1,\n    2 //error\n    }\n    _ = x\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected } </p> <p>Works:</p> <pre><code>package main\n\nfunc main() {  \n    x := []int{\n    1,\n    2,\n    }\n    x = x\n\n    y := []int{3,4,} //no error\n    y = y\n}\n</code></pre> <p>You won't get a compiler error if you leave the trailing comma when you collapse the declaration to be on a single line.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#logfatal-and-logpanic-do-more-than-log","title":"log.Fatal and log.Panic Do More Than Log","text":"<p>\u2192 beginner</p> <p>Logging libraries often provide different log levels. Unlike those logging libraries, the log package in Go does more than log if you call its <code>Fatal*()</code> and <code>Panic*()</code>functions. When your app calls those functions Go will also terminate your app :-)</p> <pre><code>package main\n\nimport \"log\"\n\nfunc main() {\n    log.Fatalln(\"Fatal Level: log entry\") //app exits here\n    log.Println(\"Normal Level: log entry\")\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#built-in-data-structure-operations-are-not-synchronized","title":"Built-in Data Structure Operations Are Not Synchronized","text":"<p>\u2192 beginner</p> <p>Even though Go has a number of features to support concurrency natively, concurrency safe data collections are not one of them :-) It's your responsibility to ensure the data collection updates are atomic. Goroutines and channels are the recommended way to implement those atomic operations, but you can also leverage the \"sync\" package if it makes sense for your application.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#iteration-values-for-strings-in-range-clauses","title":"Iteration Values For Strings in \"range\" Clauses","text":"<p>\u2192 beginner</p> <p>The index value (the first value returned by the \"range\" operation) is the index of the first byte for the current \"character\" (unicode code point/rune) returned in the second value. It's not the index for the current \"character\" like it's done in other languages. Note that an  actual character might be represented by multiple runes. Make sure to check out the \"norm\" package (golang.org/x/text/unicode/norm) if you need to work with characters.</p> <p>The <code>for range</code> clauses with string variables will try to interpret the data as UTF8 text. For any byte sequences it doesn't understand it will return 0xfffd runes (aka unicode replacement characters) instead of the actual data. If you have arbitrary (non-UTF8 text) data stored in your string variables, make sure to convert them to byte slices to get all stored data as is.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    data := \"A\\xfe\\x02\\xff\\x04\"\n    for _,v := range data {\n        fmt.Printf(\"%#x \",v)\n    }\n    //prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)\n\n    fmt.Println()\n    for _,v := range []byte(data) {\n        fmt.Printf(\"%#x \",v)\n    }\n    //prints: 0x41 0xfe 0x2 0xff 0x4 (good)\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#iterating-through-a-map-using-a-for-range-clause","title":"Iterating Through a Map Using a \"for range\" Clause","text":"<p>\u2192 beginner</p> <p>This is a gotcha if you expect the items to be in a certain order (e.g., ordered by the key value). Each map iteration will produce different results. The Go runtime tries to go an extra mile randomizing the iteration order, but it doesn't always succeed so you may get several identical map iterations. Don't be surprised to see 5 identical iterations in a row.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    m := map[string]int{\"one\":1,\"two\":2,\"three\":3,\"four\":4}\n    for k,v := range m {\n        fmt.Println(k,v)\n    }\n}\n</code></pre> <p>And if you use the Go Playground (https://play.golang.org/) you'll always get the same results because it doesn't recompile the code unless you make a change.****</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#fallthrough-behavior-in-switch-statements","title":"Fallthrough Behavior in \"switch\" Statements","text":"<p>\u2192 beginner</p> <p>The \"case\" blocks in \"switch\" statements break by default. This is different from other languages where the default behavior is to fall through to the next \"case\" block.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    isSpace := func(ch byte) bool {\n        switch(ch) {\n        case ' ': //error\n        case '\\t':\n            return true\n        }\n        return false\n    }\n\n    fmt.Println(isSpace('\\t')) //prints true (ok)\n    fmt.Println(isSpace(' '))  //prints false (not ok)\n}\n</code></pre> <p>You can force the \"case\" blocks to fall through by using the \"fallthrough\" statement at the end of each \"case\" block. You can also rewrite your switch statement to use expression lists in the \"case\" blocks.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    isSpace := func(ch byte) bool {\n        switch(ch) {\n        case ' ', '\\t':\n            return true\n        }\n        return false\n    }\n\n    fmt.Println(isSpace('\\t')) //prints true (ok)\n    fmt.Println(isSpace(' '))  //prints true (ok)\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#increments-and-decrements","title":"Increments and Decrements","text":"<p>\u2192 beginner</p> <p>Many languages have increment and decrement operators. Unlike other languages, Go doesn't support the prefix version of the operations. You also can't use these two operators in expressions.</p> <p>Fails:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    data := []int{1,2,3}\n    i := 0\n    ++i //error\n    fmt.Println(data[i++]) //error\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++ /tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting : </p> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    data := []int{1,2,3}\n    i := 0\n    i++\n    fmt.Println(data[i])\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#bitwise-not-operator","title":"Bitwise NOT Operator","text":"<p>\u2192 beginner</p> <p>Many languages use <code>~</code>as the unary NOT operator (aka bitwise complement), but Go reuses the XOR operator (<code>^</code>) for that.</p> <p>Fails:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    fmt.Println(~2) //error\n}\n</code></pre> <p>Compile Error:</p> <p>/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^ </p> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    var d uint8 = 2\n    fmt.Printf(\"%08b\\n\",^d)\n}\n</code></pre> <p>Go still uses <code>^</code>as the XOR operator, which may be confusing for some people.</p> <p>If you want you can represent a unary NOT operation (e.g, <code>NOT 0x02</code>) with a binary XOR operation (e.g., <code>0x02 XOR 0xff</code>). This could explain why <code>^</code> is reused to represent unary NOT operations.</p> <p>Go also has a special 'AND NOT' bitwise operator (<code>&amp;^</code>), which adds to the NOT operator confusion. It looks like a special feature/hack to support <code>A AND (NOT B)</code> without requiring parentheses.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    var a uint8 = 0x82\n    var b uint8 = 0x02\n    fmt.Printf(\"%08b [A]\\n\",a)\n    fmt.Printf(\"%08b [B]\\n\",b)\n\n    fmt.Printf(\"%08b (NOT B)\\n\",^b)\n    fmt.Printf(\"%08b ^ %08b = %08b [B XOR 0xff]\\n\",b,0xff,b ^ 0xff)\n\n    fmt.Printf(\"%08b ^ %08b = %08b [A XOR B]\\n\",a,b,a ^ b)\n    fmt.Printf(\"%08b &amp; %08b = %08b [A AND B]\\n\",a,b,a &amp; b)\n    fmt.Printf(\"%08b &amp;^%08b = %08b [A 'AND NOT' B]\\n\",a,b,a &amp;^ b)\n    fmt.Printf(\"%08b&amp;(^%08b)= %08b [A AND (NOT B)]\\n\",a,b,a &amp; (^b))\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#operator-precedence-differences","title":"Operator Precedence Differences","text":"<p>\u2192 beginner</p> <p>Aside from the \"bit clear\" operators (<code>&amp;^</code>) Go has a set of standard operators shared by many other languages. The operator precedence is not always the same though.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    fmt.Printf(\"0x2 &amp; 0x2 + 0x4 -&gt; %#x\\n\",0x2 &amp; 0x2 + 0x4)\n    //prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6\n    //Go:    (0x2 &amp; 0x2) + 0x4\n    //C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2\n\n    fmt.Printf(\"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\\n\",0x2 + 0x2 &lt;&lt; 0x1)\n    //prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6\n    //Go:     0x2 + (0x2 &lt;&lt; 0x1)\n    //C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8\n\n    fmt.Printf(\"0xf | 0x2 ^ 0x2 -&gt; %#x\\n\",0xf | 0x2 ^ 0x2)\n    //prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd\n    //Go:    (0xf | 0x2) ^ 0x2\n    //C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#unexported-structure-fields-are-not-encoded","title":"Unexported Structure Fields Are Not Encoded","text":"<p>\u2192 beginner</p> <p>The struct fields starting with lowercase letters will not be (json, xml, gob, etc.) encoded, so when you decode the structure you'll end up with zero values in those unexported fields.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"encoding/json\"\n)\n\ntype MyData struct {\n    One int\n    two string\n}\n\nfunc main() {\n    in := MyData{1,\"two\"}\n    fmt.Printf(\"%#v\\n\",in) //prints main.MyData{One:1, two:\"two\"}\n\n    encoded,_ := json.Marshal(in)\n    fmt.Println(string(encoded)) //prints {\"One\":1}\n\n    var out MyData\n    json.Unmarshal(encoded,&amp;out)\n\n    fmt.Printf(\"%#v\\n\",out) //prints main.MyData{One:1, two:\"\"}\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#app-exits-with-active-goroutines","title":"App Exits With Active Goroutines","text":"<p>\u2192 beginner</p> <p>The app will not wait for all your goroutines to complete. This is a common mistake for beginners in general. Everybody starts somewhere, so there's no shame in making rookie mistakes :-)</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {  \n    workerCount := 2\n\n    for i := 0; i &lt; workerCount; i++ {\n        go doit(i)\n    }\n    time.Sleep(1 * time.Second)\n    fmt.Println(\"all done!\")\n}\n\nfunc doit(workerId int) {  \n    fmt.Printf(\"[%v] is running\\n\",workerId)\n    time.Sleep(3 * time.Second)\n    fmt.Printf(\"[%v] is done\\n\",workerId)\n}\n</code></pre> <p>You'll see:</p> <p>[0] is running</p> <p>[1] is running</p> <p>all done! </p> <p>One of the most common solutions is to use a \"WaitGroup\" variable. It will allow the main goroutine to wait until all worker goroutines are done. If your app has long running workers with message processing loops you'll also need a way to signal those goroutines that it's time to exit. You can send a \"kill\" message to each worker. Another option is to close a channel all workers are receiving from. It's a simple way to signal all goroutines at once.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {  \n    var wg sync.WaitGroup\n    done := make(chan struct{})\n    workerCount := 2\n\n    for i := 0; i &lt; workerCount; i++ {\n        wg.Add(1)\n        go doit(i,done,wg)\n    }\n\n    close(done)\n    wg.Wait()\n    fmt.Println(\"all done!\")\n}\n\nfunc doit(workerId int,done &lt;-chan struct{},wg sync.WaitGroup) {  \n    fmt.Printf(\"[%v] is running\\n\",workerId)\n    defer wg.Done()\n    &lt;- done\n    fmt.Printf(\"[%v] is done\\n\",workerId)\n}\n</code></pre> <p>If you run this app you'll see:</p> <p>[0] is running</p> <p>[0] is done</p> <p>[1] is running</p> <p>[1] is done </p> <p>Looks like the workers are done before the main goroutine exits. Great! However, you'll also see this:</p> <p>fatal error: all goroutines are asleep - deadlock! </p> <p>That's not so great :-) What's going on? Why is there a deadlock? The workers exited and they executed <code>wg.Done()</code>. The app should work.</p> <p>The deadlock happens because each worker gets a copy of the original \"WaitGroup\" variable. When workers execute <code>wg.Done()</code> it has no effect on the \"WaitGroup\" variable in the main goroutine.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {  \n    var wg sync.WaitGroup\n    done := make(chan struct{})\n    wq := make(chan interface{})\n    workerCount := 2\n\n    for i := 0; i &lt; workerCount; i++ {\n        wg.Add(1)\n        go doit(i,wq,done,&amp;wg)\n    }\n\n    for i := 0; i &lt; workerCount; i++ {\n        wq &lt;- i\n    }\n\n    close(done)\n    wg.Wait()\n    fmt.Println(\"all done!\")\n}\n\nfunc doit(workerId int, wq &lt;-chan interface{},done &lt;-chan struct{},wg *sync.WaitGroup) {  \n    fmt.Printf(\"[%v] is running\\n\",workerId)\n    defer wg.Done()\n    for {\n        select {\n        case m := &lt;- wq:\n            fmt.Printf(\"[%v] m =&gt; %v\\n\",workerId,m)\n        case &lt;- done:\n            fmt.Printf(\"[%v] is done\\n\",workerId)\n            return\n        }\n    }\n}\n</code></pre> <p>Now it works as expected :-)</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#sending-to-an-unbuffered-channel-returns-as-soon-as-the-target-receiver-is-ready","title":"Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready","text":"<p>\u2192 beginner</p> <p>The sender will not be blocked until your message is processed by the receiver. Depending on the machine where you are running the code, the receiver goroutine may or may not have enough time to process the message before the sender continues its execution.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {  \n    ch := make(chan string)\n\n    go func() {\n        for m := range ch {\n            fmt.Println(\"processed:\",m)\n        }\n    }()\n\n    ch &lt;- \"cmd.1\"\n    ch &lt;- \"cmd.2\" //won't be processed\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#sending-to-an-closed-channel-causes-a-panic","title":"Sending to an Closed Channel Causes a Panic","text":"<p>\u2192 beginner</p> <p>Receiving from a closed channel is safe. The <code>ok</code> return value in a receive statement will be set to <code>false</code>indicating that no data was received. If you are receiving from a buffered channel you'll get the buffered data first and once it's empty the <code>ok</code> return value will be <code>false</code>.</p> <p>Sending data to a closed channel causes a panic. It is a documented behavior, but it's not very intuitive for new Go developers who might expect the send behavior to be similar to the receive behavior.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {  \n    ch := make(chan int)\n    for i := 0; i &lt; 3; i++ {\n        go func(idx int) {\n            ch &lt;- (idx + 1) * 2\n        }(i)\n    }\n\n    //get the first result\n    fmt.Println(&lt;-ch)\n    close(ch) //not ok (you still have other senders)\n    //do other work\n    time.Sleep(2 * time.Second)\n}\n</code></pre> <p>Depending on your application the fix will be different. It might be a minor code change or it might require a change in your application design. Either way, you'll need to make sure your application doesn't try to send data to a closed channel.</p> <p>The buggy example can be fixed by using a special cancellation channel to signal the remaining workers that their results are no longer neeeded.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {  \n    ch := make(chan int)\n    done := make(chan struct{})\n    for i := 0; i &lt; 3; i++ {\n        go func(idx int) {\n            select {\n            case ch &lt;- (idx + 1) * 2: fmt.Println(idx,\"sent result\")\n            case &lt;- done: fmt.Println(idx,\"exiting\")\n            }\n        }(i)\n    }\n\n    //get first result\n    fmt.Println(\"result:\",&lt;-ch)\n    close(done)\n    //do other work\n    time.Sleep(3 * time.Second)\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#using-nil-channels","title":"Using \"nil\" Channels","text":"<p>\u2192 beginner</p> <p>Send and receive operations on a <code>nil</code> channel block forver. It's a well documented behavior, but it can be a surprise for new Go developers.</p> <pre><code>package main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {  \n    var ch chan int\n    for i := 0; i &lt; 3; i++ {\n        go func(idx int) {\n            ch &lt;- (idx + 1) * 2\n        }(i)\n    }\n\n    //get first result\n    fmt.Println(\"result:\",&lt;-ch)\n    //do other work\n    time.Sleep(2 * time.Second)\n}\n</code></pre> <p>If you run the code you'll see a runtime error like this: <code>fatal error: all goroutines are asleep - deadlock!</code></p> <p>This behavior can be used as a way to dynamically enable and disable <code>case</code> blocks in a <code>select</code> statement.</p> <pre><code>package main\n\nimport \"fmt\"  \nimport \"time\"\n\nfunc main() {  \n    inch := make(chan int)\n    outch := make(chan int)\n\n    go func() {\n        var in &lt;- chan int = inch\n        var out chan &lt;- int\n        var val int\n        for {\n            select {\n            case out &lt;- val:\n                out = nil\n                in = inch\n            case val = &lt;- in:\n                out = outch\n                in = nil\n            }\n        }\n    }()\n\n    go func() {\n        for r := range outch {\n            fmt.Println(\"result:\",r)\n        }\n    }()\n\n    time.Sleep(0)\n    inch &lt;- 1\n    inch &lt;- 2\n    time.Sleep(3 * time.Second)\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#methods-with-value-receivers-cant-change-the-original-value","title":"Methods with Value Receivers Can't Change the Original Value","text":"<p>\u2192 beginner</p> <p>Method receivers are like regular function arguments. If it's declared to be a value then your function/method gets a copy of your receiver argument. This means making changes to the receiver will not affect the original value unless your receiver is a map or slice variable and you are updating the items in the collection or the fields you are updating in the receiver are pointers.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {  \n    num int\n    key *string\n    items map[string]bool\n}\n\nfunc (this *data) pmethod() {  \n    this.num = 7\n}\n\nfunc (this data) vmethod() {  \n    this.num = 8\n    *this.key = \"v.key\"\n    this.items[\"vmethod\"] = true\n}\n\nfunc main() {  \n    key := \"key.1\"\n    d := data{1,&amp;key,make(map[string]bool)}\n\n    fmt.Printf(\"num=%v key=%v items=%v\\n\",d.num,*d.key,d.items)\n    //prints num=1 key=key.1 items=map[]\n\n    d.pmethod()\n    fmt.Printf(\"num=%v key=%v items=%v\\n\",d.num,*d.key,d.items) \n    //prints num=7 key=key.1 items=map[]\n\n    d.vmethod()\n    fmt.Printf(\"num=%v key=%v items=%v\\n\",d.num,*d.key,d.items)\n    //prints num=7 key=v.key items=map[vmethod:true]\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#closing-http-response-body","title":"Closing HTTP Response Body","text":"<p>\u2192 intermediate</p> <p>When you make requests using the standard http library you get a http response variable. If you don't read the response body you still need  to close it. Note that you must do it for empty responses too. It's very easy to forget especially for new Go developers.</p> <p>Some new Go developers do try to close the response body, but they do it in the wrong place.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"https://api.ipify.org?format=json\")\n    defer resp.Body.Close()//not ok\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(string(body))\n}\n</code></pre> <p>This code works for successful requests, but if the http request fails the <code>resp</code> variable might be <code>nil</code>, which will cause a runtime panic.</p> <p>The most common why to close the response body is by using a <code>defer</code> call after the http response error check.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"https://api.ipify.org?format=json\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    defer resp.Body.Close()//ok, most of the time :-)\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(string(body))\n}\n</code></pre> <p>Most of the time when your http request fails the <code>resp</code> variable will be <code>nil</code> and the <code>err</code> variable will be <code>non-nil</code>. However, when you get a redirection failure both variables will be <code>non-nil</code>. This means you can still end up with a leak.</p> <p>You can fix this leak by adding a call to close <code>non-nil</code> response bodies in the http response error handling block. Another option is to use one <code>defer</code> call to close response bodies for all failed and successful requests.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    resp, err := http.Get(\"https://api.ipify.org?format=json\")\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(string(body))\n}\n</code></pre> <p>The orignal implementation for <code>resp.Body.Close()</code> also reads and discards the remaining response body data. This ensured that the http connection could be reused for another request if the keepalive http connection behavior is enabled. The latest http client behavior is different. Now it's your responsibility to read and discard the remaining response data. If you don't do it the http connection might be closed instead of being reused. This little gotcha is supposed to be documented in Go 1.5.</p> <p>If reusing the http connection is important for your application you might need to add something like this at the end of your response processing logic:</p> <pre><code>_, err = io.Copy(ioutil.Discard, resp.Body)\n</code></pre> <p>It will be necessary if you don't read the entire response body right away, which might happen if you are processing json API responses with  code like this:</p> <pre><code>json.NewDecoder(resp.Body).Decode(&amp;data)\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#closing-http-connections","title":"Closing HTTP Connections","text":"<p>\u2192 intermediate</p> <p>Some HTTP servers keep network connections open for a while (based on the HTTP 1.1 spec and the server \"keep-alive\" configurations). By default, the standard http library will close the network connections only when the target HTTP server asks for it. This means your app may run out of sockets/file descriptors under certain conditions.</p> <p>You can ask the http library to close the connection after your request is done by setting the <code>Close</code> field in the request variable to <code>true</code>.</p> <p>Another option is to add a <code>Connection</code> request header and set it to <code>close</code>. The target HTTP server should respond with a <code>Connection: close</code> header too. When the http library sees this response header it will also close the connection.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    req, err := http.NewRequest(\"GET\",\"http://golang.org\",nil)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    req.Close = true\n    //or do this:\n    //req.Header.Add(\"Connection\", \"close\")\n\n    resp, err := http.DefaultClient.Do(req)\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(len(string(body)))\n}\n</code></pre> <p>You can also disable http connection reuse globally. You'll need to create a custom http transport configuration for it.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    tr := &amp;http.Transport{DisableKeepAlives: true}\n    client := &amp;http.Client{Transport: tr}\n\n    resp, err := client.Get(\"http://golang.org\")\n    if resp != nil {\n        defer resp.Body.Close()\n    }\n\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(resp.StatusCode)\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n\n    fmt.Println(len(string(body)))\n}\n</code></pre> <p>If you send a lot of requests to the same HTTP server it's ok to keep the network connection open. However, if your app sends one or two requests to many different HTTP servers in a short period of time it's a good idea to close the network connections right after your app receives the responses. Increasing the open file limit might be a good idea too. The correct solution depends on your application though.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#json-encoder-adds-a-newline-character","title":"JSON Encoder Adds a Newline Character","text":"<p>\u2192 intermediate</p> <p>You are writing a test for your JSON encoding function when you discover that your tests fail because you are not getting the expected value. What happened? If you are using the JSON Encoder object then you'll get an extra newline character at the end of your encoded JSON object.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"encoding/json\"\n  \"bytes\"\n)\n\nfunc main() {\n  data := map[string]int{\"key\": 1}\n\n  var b bytes.Buffer\n  json.NewEncoder(&amp;b).Encode(data)\n\n  raw,_ := json.Marshal(data)\n\n  if b.String() == string(raw) {\n    fmt.Println(\"same encoded data\")\n  } else {\n    fmt.Printf(\"'%s' != '%s'\\n\",raw,b.String())\n    //prints:\n    //'{\"key\":1}' != '{\"key\":1}\\n'\n  }\n}\n</code></pre> <p>The JSON Encoder object is designed for streaming. Streaming with JSON usually means newline delimited JSON objects and this is why the Encode method adds a newline character. This is a documented behavior, but it's commonly overlooked or forgotten.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#json-package-escapes-special-html-characters-in-keys-and-string-values","title":"JSON Package Escapes Special HTML Characters in Keys and String Values","text":"<p>\u2192 Intermediate</p> <p>This is a documented behavior, but you have to be careful reading all of the JSON package documentation to learn about it. The <code>SetEscapeHTML</code> method description talks about the default encoding behavior for the and, less than and greater than characters.</p> <p>This is a very unfortunate design decision by the Go team for a number of reasons. First, you can't disable this behavior for the <code>json.Marshal</code> calls. Second, this is a badly implemented security feature because it assumes that doing HTML encoding is sufficient to protect against XSS vulnerabilities in all web applications. There are a lot of different contexts where the data can be used and each context requires its own encoding method. And finally, it's bad because it assumes that the primary use case for JSON is a web page, which breaks the configuration libraries and the REST/HTTP APIs by default.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"encoding/json\"\n  \"bytes\"\n)\n\nfunc main() {\n  data := \"x &lt; y\"\n\n  raw,_ := json.Marshal(data)\n  fmt.Println(string(raw))\n  //prints: \"x \\u003c y\" &lt;- probably not what you expected\n\n  var b1 bytes.Buffer\n  json.NewEncoder(&amp;b1).Encode(data)\n  fmt.Println(b1.String())\n  //prints: \"x \\u003c y\" &lt;- probably not what you expected\n\n  var b2 bytes.Buffer\n  enc := json.NewEncoder(&amp;b2)\n  enc.SetEscapeHTML(false)\n  enc.Encode(data)\n  fmt.Println(b2.String())\n  //prints: \"x &lt; y\" &lt;- looks better\n}\n</code></pre> <p>A suggestion to the Go team... Make it an opt-in.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#unmarshalling-json-numbers-into-interface-values","title":"Unmarshalling JSON Numbers into Interface Values","text":"<p>\u2192 intermediate</p> <p>By default, Go treats numeric values in JSON as <code>float64</code> numbers when you decode/unmarshal JSON data into an interface. This means the following code will fail with a panic:</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n)\n\nfunc main() {\n  var data = []byte(`{\"status\": 200}`)\n\n  var result map[string]interface{}\n  if err := json.Unmarshal(data, &amp;result); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  var status = result[\"status\"].(int) //error\n  fmt.Println(\"status value:\",status)\n}\n</code></pre> <p>Runtime Panic:</p> <p>panic: interface conversion: interface is float64, not int </p> <p>If the JSON value you are trying to decode is an integer you have serveral options. Option one: use the float value as-is :-) Option two: convert the float value to the integer type you need.</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n)\n\nfunc main() {\n  var data = []byte(`{\"status\": 200}`)\n\n  var result map[string]interface{}\n  if err := json.Unmarshal(data, &amp;result); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  var status = uint64(result[\"status\"].(float64)) //ok\n  fmt.Println(\"status value:\",status)\n}\n</code></pre> <p>Option three: use a <code>Decoder</code> type to unmarshal JSON and tell it to represent JSON numbers using the <code>Number</code> interface type.</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"bytes\"\n  \"fmt\"\n)\n\nfunc main() {\n  var data = []byte(`{\"status\": 200}`)\n\n  var result map[string]interface{}\n  var decoder = json.NewDecoder(bytes.NewReader(data))\n  decoder.UseNumber()\n\n  if err := decoder.Decode(&amp;result); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  var status,_ = result[\"status\"].(json.Number).Int64() //ok\n  fmt.Println(\"status value:\",status)\n}\n</code></pre> <p>You can use the string representation of your <code>Number</code> value to unmarshal it to a different numeric type:</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"bytes\"\n  \"fmt\"\n)\n\nfunc main() {\n  var data = []byte(`{\"status\": 200}`)\n\n  var result map[string]interface{}\n  var decoder = json.NewDecoder(bytes.NewReader(data))\n  decoder.UseNumber()\n\n  if err := decoder.Decode(&amp;result); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  var status uint64\n  if err := json.Unmarshal([]byte(result[\"status\"].(json.Number).String()), &amp;status); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  fmt.Println(\"status value:\",status)\n}\n</code></pre> <p>Option four: use a <code>struct</code> type that maps your numeric value to the numeric type you need.</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"bytes\"\n  \"fmt\"\n)\n\nfunc main() {\n  var data = []byte(`{\"status\": 200}`)\n\n  var result struct {\n    Status uint64 `json:\"status\"`\n  }\n\n  if err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != nil {\n    fmt.Println(\"error:\", err)\n    return\n  }\n\n  fmt.Printf(\"result =&gt; %+v\",result)\n  //prints: result =&gt; {Status:200}\n}\n</code></pre> <p>Option five: use a <code>struct</code> that maps your numeric value to the <code>json.RawMessage</code> type if you need to defer the value decoding.</p> <p>This option is useful if you have to perform conditional JSON field decoding where the field type or structure might change.</p> <pre><code>package main\n\nimport (\n  \"encoding/json\"\n  \"bytes\"\n  \"fmt\"\n)\n\nfunc main() {\n  records := [][]byte{\n    []byte(`{\"status\": 200, \"tag\":\"one\"}`),\n    []byte(`{\"status\":\"ok\", \"tag\":\"two\"}`),\n  }\n\n  for idx, record := range records {\n    var result struct {\n      StatusCode uint64\n      StatusName string\n      Status json.RawMessage `json:\"status\"`\n      Tag string             `json:\"tag\"`\n    }\n\n    if err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result); err != nil {\n      fmt.Println(\"error:\", err)\n      return\n    }\n\n    var sstatus string\n    if err := json.Unmarshal(result.Status, &amp;sstatus); err == nil {\n      result.StatusName = sstatus\n    }\n\n    var nstatus uint64\n    if err := json.Unmarshal(result.Status, &amp;nstatus); err == nil {\n      result.StatusCode = nstatus\n    }\n\n    fmt.Printf(\"[%v] result =&gt; %+v\\n\",idx,result)\n  }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#json-string-values-will-not-be-ok-with-hex-or-other-non-utf8-escape-sequences","title":"JSON String Values Will Not Be Ok with Hex or Other non-UTF8 Escape Sequences","text":"<p>\u2192 intermediate</p> <p>Go expects string values to be UTF8 encoded. This means you can't have arbitrary hex escaped binary data in your JSON strings (and you also have to escape the backslash character). This is really a JSON gotcha Go inherited, but it happens often enough in Go apps that it makes sense to mention it anyways.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"encoding/json\"\n)\n\ntype config struct {\n  Data string `json:\"data\"`\n}\n\nfunc main() {\n  raw := []byte(`{\"data\":\"\\xc2\"}`)\n  var decoded config\n\n  if err := json.Unmarshal(raw, &amp;decoded); err != nil {\n        fmt.Println(err)\n    //prints: invalid character 'x' in string escape code\n    }\n\n}\n</code></pre> <p>The Unmarshal/Decode calls will fail if Go sees a hex escape sequence. If you do need to have a backslash in you string make sure to escape it with another backlash. If you want to use hex encoded binary data you can escape the backslash and then do your own hex escaping with the decoded data in your JSON string.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"encoding/json\"\n)\n\ntype config struct {\n  Data string `json:\"data\"`\n}\n\nfunc main() {\n  raw := []byte(`{\"data\":\"\\\\xc2\"}`)\n\n  var decoded config\n\n  json.Unmarshal(raw, &amp;decoded)\n\n  fmt.Printf(\"%#v\",decoded) //prints: main.config{Data:\"\\\\xc2\"}\n  //todo: do your own hex escape decoding for decoded.Data\n}\n</code></pre> <p>Another option is to use the byte array/slice data type in your JSON object, but the binary data will have to be base64 encoded.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n  \"encoding/json\"\n)\n\ntype config struct {\n  Data []byte `json:\"data\"`\n}\n\nfunc main() {\n  raw := []byte(`{\"data\":\"wg==\"}`)\n  var decoded config\n\n  if err := json.Unmarshal(raw, &amp;decoded); err != nil {\n          fmt.Println(err)\n      }\n\n  fmt.Printf(\"%#v\",decoded) //prints: main.config{Data:[]uint8{0xc2}}\n}\n</code></pre> <p>Something else to watch out for is the Unicode replacement character (U+FFFD). Go will use the replacement character instead of invalid UTF8, so the Unmarshal/Decode call will not fail, but the string value you get might not be what you expected.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#comparing-structs-arrays-slices-and-maps","title":"Comparing Structs, Arrays, Slices, and Maps","text":"<p>\u2192 intermediate</p> <p>You can use the equality operator, <code>==</code>, to compare struct variables if each structure field can be compared with the equality operator.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    num int\n    fp float32\n    complex complex64\n    str string\n    char rune\n    yes bool\n    events &lt;-chan string\n    handler interface{}\n    ref *byte\n    raw [10]byte\n}\n\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\"v1 == v2:\",v1 == v2) //prints: v1 == v2: true\n}\n</code></pre> <p>If any of the struct fields are not comparable then using the equality operator will result in compile time errors. Note that arrays are comparable only if their data items are comparable.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    num int                //ok\n    checks [10]func() bool //not comparable\n    doit func() bool       //not comparable\n    m map[string] string   //not comparable\n    bytes []byte           //not comparable\n}\n\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\"v1 == v2:\",v1 == v2)\n}\n</code></pre> <p>Go does provide a number of helper functions to compare variables that can't be compared using the comparison operators.</p> <p>The most generic solution is to use the <code>DeepEqual()</code> function in the reflect package.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype data struct {\n    num int                //ok\n    checks [10]func() bool //not comparable\n    doit func() bool       //not comparable\n    m map[string] string   //not comparable\n    bytes []byte           //not comparable\n}\n\nfunc main() {\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\"v1 == v2:\",reflect.DeepEqual(v1,v2)) //prints: v1 == v2: true\n\n    m1 := map[string]string{\"one\": \"a\",\"two\": \"b\"}\n    m2 := map[string]string{\"two\": \"b\", \"one\": \"a\"}\n    fmt.Println(\"m1 == m2:\",reflect.DeepEqual(m1, m2)) //prints: m1 == m2: true\n\n    s1 := []int{1, 2, 3}\n    s2 := []int{1, 2, 3}\n    fmt.Println(\"s1 == s2:\",reflect.DeepEqual(s1, s2)) //prints: s1 == s2: true\n}\n</code></pre> <p>Aside from being slow (which may or may not be a deal breaker for your application), <code>DeepEqual()</code> also has its own gotchas.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    var b1 []byte = nil\n    b2 := []byte{}\n    fmt.Println(\"b1 == b2:\",reflect.DeepEqual(b1, b2)) //prints: b1 == b2: false\n}\n</code></pre> <p><code>DeepEqual()</code> doesn't consider an empty slice to be equal to a \"nil\" slice. This behavior is different from the behavior you get using the <code>bytes.Equal()</code> function. <code>bytes.Equal()</code> considers \"nil\" and empty slices to be equal.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"bytes\"\n)\n\nfunc main() {\n    var b1 []byte = nil\n    b2 := []byte{}\n    fmt.Println(\"b1 == b2:\",bytes.Equal(b1, b2)) //prints: b1 == b2: true\n}\n</code></pre> <p><code>DeepEqual()</code> isn't always perfect comparing slices.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"encoding/json\"\n)\n\nfunc main() {\n    var str string = \"one\"\n    var in interface{} = \"one\"\n    fmt.Println(\"str == in:\",str == in,reflect.DeepEqual(str, in))\n    //prints: str == in: true true\n\n    v1 := []string{\"one\",\"two\"}\n    v2 := []interface{}{\"one\",\"two\"}\n    fmt.Println(\"v1 == v2:\",reflect.DeepEqual(v1, v2))\n    //prints: v1 == v2: false (not ok)\n\n    data := map[string]interface{}{\n        \"code\": 200,\n        \"value\": []string{\"one\",\"two\"},\n    }\n    encoded, _ := json.Marshal(data)\n    var decoded map[string]interface{}\n    json.Unmarshal(encoded, &amp;decoded)\n    fmt.Println(\"data == decoded:\",reflect.DeepEqual(data, decoded))\n    //prints: data == decoded: false (not ok)\n}\n</code></pre> <p>If your byte slices (or strings) contain text data you might be tempted to use <code>ToUpper()</code> or <code>ToLower()</code> from the \"bytes\" and \"strings\" packages when you need to compare values in a case insensitive manner (before using <code>==</code>,<code>bytes.Equal()</code>, or <code>bytes.Compare()</code>). It will work for English text, but it will not work for text in many other languages. <code>strings.EqualFold()</code> and <code>bytes.EqualFold()</code> should be used instead.</p> <p>If your byte slices contain secrets (e.g., cryptographic hashes, tokens, etc.) that need to be validated against user-provided data, don't use <code>reflect.DeepEqual()</code>, <code>bytes.Equal()</code>, or <code>bytes.Compare()</code> because those functions will make your application vulnerable to timing attacks. To avoid leaking the timing information use the functions from the 'crypto/subtle' package (e.g., <code>subtle.ConstantTimeCompare()</code>).</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#recovering-from-a-panic","title":"Recovering From a Panic","text":"<p>\u2192 intermediate</p> <p>The <code>recover()</code> function can be used to catch/intercept a panic. Calling <code>recover()</code> will do the trick only when it's done in a deferred function.</p> <p>Incorrect:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    recover() //doesn't do anything\n    panic(\"not good\")\n    recover() //won't be executed :)\n    fmt.Println(\"ok\")\n}\n</code></pre> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    defer func() {\n        fmt.Println(\"recovered:\",recover())\n    }()\n\n    panic(\"not good\")\n}\n</code></pre> <p>The call to <code>recover()</code> works only if it's called directly in your deferred function.</p> <p>Fails:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc doRecover() {\n    fmt.Println(\"recovered =&gt;\",recover()) //prints: recovered =&gt; &lt;nil&gt;\n}\n\nfunc main() {\n    defer func() {\n        doRecover() //panic is not recovered\n    }()\n\n    panic(\"not good\")\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#updating-and-referencing-item-values-in-slice-array-and-map-range-clauses","title":"Updating and Referencing Item Values in Slice, Array, and Map \"range\" Clauses","text":"<p>\u2192 intermediate</p> <p>The data values generated in the \"range\" clause are copies of the actual collection elements. They are not references to the original items. This means that updating the values will not change the original data. It also means that taking the address of the values will not give you pointers to the original data.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := []int{1,2,3}\n    for _,v := range data {\n        v *= 10 //original item is not changed\n    }\n\n    fmt.Println(\"data:\",data) //prints data: [1 2 3]\n}\n</code></pre> <p>If you need to update the original collection record value use the index operator to access the data.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := []int{1,2,3}\n    for i,_ := range data {\n        data[i] *= 10\n    }\n\n    fmt.Println(\"data:\",data) //prints data: [10 20 30]\n}\n</code></pre> <p>If your collection holds pointer values then the rules are slightly different. You still need to use the index operator if you want the original record to point to another value, but you can update the data stored at the target location using the second value in the \"for range\" clause.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    data := []*struct{num int} {{1},{2},{3}}\n\n    for _,v := range data {\n        v.num *= 10\n    }\n\n    fmt.Println(data[0],data[1],data[2]) //prints &amp;{10} &amp;{20} &amp;{30}\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#hidden-data-in-slices","title":"\"Hidden\" Data in Slices","text":"<p>\u2192 intermediate</p> <p>When you reslice a slice, the new slice will reference the array of the original slice. If you forget about this behavior it can lead to unexpected memory usage if your application allocates large temporary slices creating new slices from them to refer to small sections of the original data.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc get() []byte {\n    raw := make([]byte,10000)\n    fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000 &lt;byte_addr_x&gt;\n    return raw[:3]\n}\n\nfunc main() {\n    data := get()\n    fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 10000 &lt;byte_addr_x&gt;\n}\n</code></pre> <p>To avoid this trap make sure to copy the data you need from the temporary slice (instead of reslicing it).</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc get() []byte {\n    raw := make([]byte,10000)\n    fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000 &lt;byte_addr_x&gt;\n    res := make([]byte,3)\n    copy(res,raw[:3])\n    return res\n}\n\nfunc main() {\n    data := get()\n    fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 3 &lt;byte_addr_y&gt;\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#slice-data-corruption","title":"Slice Data \"Corruption\"","text":"<p>\u2192 intermediate</p> <p>Let's say you need to rewrite a path (stored in a slice). You reslice the path to reference each directory modifying the first folder name and then you combine the names to create a new path.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"bytes\"\n)\n\nfunc main() {\n    path := []byte(\"AAAA/BBBBBBBBB\")\n    sepIndex := bytes.IndexByte(path,'/')\n    dir1 := path[:sepIndex]\n    dir2 := path[sepIndex+1:]\n    fmt.Println(\"dir1 =&gt;\",string(dir1)) //prints: dir1 =&gt; AAAA\n    fmt.Println(\"dir2 =&gt;\",string(dir2)) //prints: dir2 =&gt; BBBBBBBBB\n\n    dir1 = append(dir1,\"suffix\"...)\n    path = bytes.Join([][]byte{dir1,dir2},[]byte{'/'})\n\n    fmt.Println(\"dir1 =&gt;\",string(dir1)) //prints: dir1 =&gt; AAAAsuffix\n    fmt.Println(\"dir2 =&gt;\",string(dir2)) //prints: dir2 =&gt; uffixBBBB (not ok)\n\n    fmt.Println(\"new path =&gt;\",string(path))\n}\n</code></pre> <p>It didn't work as you expected. Instead of \"AAAAsuffix/BBBBBBBBB\" you ended up with \"AAAAsuffix/uffixBBBB\". It happened because both directory slices referenced the same underlying array data from the original path slice. This means that the original path is also modified. Depending on your application this might be a problem too.</p> <p>This problem can fixed by allocating new slices and copying the data you need. Another option is to use the full slice expression.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"bytes\"\n)\n\nfunc main() {\n    path := []byte(\"AAAA/BBBBBBBBB\")\n    sepIndex := bytes.IndexByte(path,'/')\n    dir1 := path[:sepIndex:sepIndex] //full slice expression\n    dir2 := path[sepIndex+1:]\n    fmt.Println(\"dir1 =&gt;\",string(dir1)) //prints: dir1 =&gt; AAAA\n    fmt.Println(\"dir2 =&gt;\",string(dir2)) //prints: dir2 =&gt; BBBBBBBBB\n\n    dir1 = append(dir1,\"suffix\"...)\n    path = bytes.Join([][]byte{dir1,dir2},[]byte{'/'})\n\n    fmt.Println(\"dir1 =&gt;\",string(dir1)) //prints: dir1 =&gt; AAAAsuffix\n    fmt.Println(\"dir2 =&gt;\",string(dir2)) //prints: dir2 =&gt; BBBBBBBBB (ok now)\n\n    fmt.Println(\"new path =&gt;\",string(path))\n}\n</code></pre> <p>The extra parameter in the full slice expression controls the capacity for the new slice. Now appending to that slice will trigger a new buffer allocation instead of overwriting the data in the second slice.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#stale-slices","title":"\"Stale\" Slices","text":"<p>\u2192 intermediate</p> <p>Multiple slices can reference the same data. This can happen when you create a new slice from an existing slice, for example. If your application relies on this behavior to function properly then you'll need to worry about \"stale\" slices.</p> <p>At some point adding data to one of the slices will result in a new array allocation when the original array can't hold any more new data. Now other slices will point to the old array (with old data).</p> <pre><code>import \"fmt\"\n\nfunc main() {\n    s1 := []int{1,2,3}\n    fmt.Println(len(s1),cap(s1),s1) //prints 3 3 [1 2 3]\n\n    s2 := s1[1:]\n    fmt.Println(len(s2),cap(s2),s2) //prints 2 2 [2 3]\n\n    for i := range s2 { s2[i] += 20 }\n\n    //still referencing the same array\n    fmt.Println(s1) //prints [1 22 23]\n    fmt.Println(s2) //prints [22 23]\n\n    s2 = append(s2,4)\n\n    for i := range s2 { s2[i] += 10 }\n\n    //s1 is now \"stale\"\n    fmt.Println(s1) //prints [1 22 23]\n    fmt.Println(s2) //prints [32 33 14]\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#type-declarations-and-methods","title":"Type Declarations and Methods","text":"<p>\u2192 intermediate</p> <p>When you create a type declaration by defining a new type from an existing (non-interface) type, you don't inherit the methods defined for that existing type.</p> <p>Fails:</p> <pre><code>package main\n\nimport \"sync\"\n\ntype myMutex sync.Mutex\n\nfunc main() {\n    var mtx myMutex\n    mtx.Lock() //error\n    mtx.Unlock() //error\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock) </p> <p>If you do need the methods from the original type you can define a new struct type embedding the original type as an anonymous field.</p> <p>Works:</p> <pre><code>package main\n\nimport \"sync\"\n\ntype myLocker struct {\n    sync.Mutex\n}\n\nfunc main() {\n    var lock myLocker\n    lock.Lock() //ok\n    lock.Unlock() //ok\n}\n</code></pre> <p>Interface type declarations also retain their method sets.</p> <p>Works:</p> <pre><code>package main\n\nimport \"sync\"\n\ntype myLocker sync.Locker\n\nfunc main() {\n    var lock myLocker = new(sync.Mutex)\n    lock.Lock() //ok\n    lock.Unlock() //ok\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#breaking-out-of-for-switch-and-for-select-code-blocks","title":"Breaking Out of \"for switch\" and \"for select\" Code Blocks","text":"<p>\u2192 intermediate</p> <p>A \"break\" statement without a label only gets you out of the inner switch/select block. If using a \"return\" statement is not an option then defining a label for the outer loop is the next best thing.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    loop:\n        for {\n            switch {\n            case true:\n                fmt.Println(\"breaking out...\")\n                break loop\n            }\n        }\n\n    fmt.Println(\"out!\")\n}\n</code></pre> <p>A \"goto\" statement will do the trick too...</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#iteration-variables-and-closures-in-for-statements","title":"Iteration Variables and Closures in \"for\" Statements","text":"<p>\u2192 intermediate</p> <p>Info</p> <p>solved in go 1.22 -&gt; now the itration variable is per iteration basis not per loop basis</p> <p>This is the most common gotcha in Go. The iteration variables in <code>for</code> statements are reused in each iteration. This means that each closure (aka function literal) created in your <code>for</code> loop will reference the same variable (and they'll get that variable's value at the time those goroutines start executing).</p> <p>Incorrect:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    data := []string{\"one\",\"two\",\"three\"}\n\n    for _,v := range data {\n        go func() {\n            fmt.Println(v)\n        }()\n    }\n\n    time.Sleep(3 * time.Second)\n    //goroutines print: three, three, three\n}\n</code></pre> <p>The easiest solution (that doesn't require any changes to the goroutine) is to save the current iteration variable value in a local variable inside the <code>for</code> loop block.</p> <p>Works:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    data := []string{\"one\",\"two\",\"three\"}\n\n    for _,v := range data {\n        vcopy := v //\n        go func() {\n            fmt.Println(vcopy)\n        }()\n    }\n\n    time.Sleep(3 * time.Second)\n    //goroutines print: one, two, three\n}\n</code></pre> <p>Another solution is to pass the current iteration variable as a parameter to the anonymous goroutine.</p> <p>Works:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    data := []string{\"one\",\"two\",\"three\"}\n\n    for _,v := range data {\n        go func(in string) {\n            fmt.Println(in)\n        }(v)\n    }\n\n    time.Sleep(3 * time.Second)\n    //goroutines print: one, two, three\n}\n</code></pre> <p>Here's a slightly more complicated version of the trap.</p> <p>Incorrect:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype field struct {\n    name string\n}\n\nfunc (p *field) print() {\n    fmt.Println(p.name)\n}\n\nfunc main() {\n    data := []field{{\"one\"},{\"two\"},{\"three\"}}\n\n    for _,v := range data {\n        go v.print()\n    }\n\n    time.Sleep(3 * time.Second)\n    //goroutines print: three, three, three\n}\n</code></pre> <p>Works:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype field struct {\n    name string\n}\n\nfunc (p *field) print() {\n    fmt.Println(p.name)\n}\n\nfunc main() {\n    data := []field{{\"one\"},{\"two\"},{\"three\"}}\n\n    for _,v := range data {\n        v := v\n        go v.print()\n    }\n\n    time.Sleep(3 * time.Second)\n    //goroutines print: one, two, three\n}\n</code></pre> <p>What do you think you'll see when you run this code (and why)?</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype field struct {\n    name string\n}\n\nfunc (p *field) print() {\n    fmt.Println(p.name)\n}\n\nfunc main() {\n    data := []*field{{\"one\"},{\"two\"},{\"three\"}}\n\n    for _,v := range data {\n        go v.print()\n    }\n\n    time.Sleep(3 * time.Second)\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#deferred-function-call-argument-evaluation","title":"Deferred Function Call Argument Evaluation","text":"<p>\u2192 intermediate</p> <p>Arguments for a deferred function call are evaluated when the <code>defer</code> statement is evaluated (not when the function is actually executing). The same rules apply when you defer a method call. The structure value is also saved along with the explicit method parameters and the closed variables.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i int = 1\n\n    defer fmt.Println(\"result =&gt;\",func() int { return i * 2 }())\n    i++\n    //prints: result =&gt; 2 (not ok if you expected 4)\n}\n</code></pre> <p>If you have pointer parameters it is possible to change the values they point to because only the pointer is saved when the <code>defer</code> statement is evaluated.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n)\n\nfunc main() {\n  i := 1\n  defer func (in *int) { fmt.Println(\"result =&gt;\", *in) }(&amp;i)\n\n  i = 2\n  //prints: result =&gt; 2\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#deferred-function-call-execution","title":"Deferred Function Call Execution","text":"<p>\u2192 intermediate</p> <p>The deferred calls are executed at the end of the containing function (and in reverse order) and not at the end of the containing code block. It's an easy mistake to make for new Go developers confusing the deferred code execution rules with the variable scoping rules. It can become a problem if you have a long running function with a <code>for</code> loop that tries to <code>defer</code> resource cleanup calls in each iteration.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    if len(os.Args) != 2 {\n        os.Exit(-1)\n    }\n\n    start, err := os.Stat(os.Args[1])\n    if err != nil || !start.IsDir(){\n        os.Exit(-1)\n    }\n\n    var targets []string\n    filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        if !fi.Mode().IsRegular() {\n            return nil\n        }\n\n        targets = append(targets,fpath)\n        return nil\n    })\n\n    for _,target := range targets {\n        f, err := os.Open(target)\n        if err != nil {\n            fmt.Println(\"bad target:\",target,\"error:\",err) //prints error: too many open files\n            break\n        }\n        defer f.Close() //will not be closed at the end of this code block\n        //do something with the file...\n    }\n}\n</code></pre> <p>One way to solve the problem is by wrapping the code block in a function.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n)\n\nfunc main() {\n    if len(os.Args) != 2 {\n        os.Exit(-1)\n    }\n\n    start, err := os.Stat(os.Args[1])\n    if err != nil || !start.IsDir(){\n        os.Exit(-1)\n    }\n\n    var targets []string\n    filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {\n        if err != nil {\n            return err\n        }\n\n        if !fi.Mode().IsRegular() {\n            return nil\n        }\n\n        targets = append(targets,fpath)\n        return nil\n    })\n\n    for _,target := range targets {\n        func() {\n            f, err := os.Open(target)\n            if err != nil {\n                fmt.Println(\"bad target:\",target,\"error:\",err)\n                return\n            }\n            defer f.Close() //ok\n            //do something with the file...\n        }()\n    }\n}\n</code></pre> <p>Another option is to get rid of the <code>defer</code> statement :-)</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#failed-type-assertions","title":"Failed Type Assertions","text":"<p>\u2192 intermediate</p> <p>Failed type assertions return the \"zero value\" for the target type used in the assertion statement. This can lead to unexpected behavior when it's mixed with variable shadowing.</p> <p>Incorrect:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var data interface{} = \"great\"\n\n    if data, ok := data.(int); ok {\n        fmt.Println(\"[is an int] value =&gt;\",data)\n    } else {\n        fmt.Println(\"[not an int] value =&gt;\",data)\n        //prints: [not an int] value =&gt; 0 (not \"great\")\n    }\n}\n</code></pre> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var data interface{} = \"great\"\n\n    if res, ok := data.(int); ok {\n        fmt.Println(\"[is an int] value =&gt;\",res)\n    } else {\n        fmt.Println(\"[not an int] value =&gt;\",data)\n        //prints: [not an int] value =&gt; great (as expected)\n    }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#blocked-goroutines-and-resource-leaks","title":"Blocked Goroutines and Resource Leaks","text":"<p>\u2192 intermediate</p> <p>Rob Pike talked about a number of fundamental concurrency patterns in his \"Go Concurrency Patterns\" presentation at Google I/O in 2012. Fetching the first result from a number of targets is one of them.</p> <pre><code>func First(query string, replicas ...Search) Result {\n    c := make(chan Result)\n    searchReplica := func(i int) { c &lt;- replicas[i](query) }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n    return &lt;-c\n}\n</code></pre> <p>The function starts a goroutines for each search replica. Each goroutine sends its search result to the result channel. The first value from the result channel is returned. What about the results from the other goroutines? What about the goroutines themselves?</p> <p>The result channel in the <code>First()</code> function is unbuffered. This means that only the first goroutine returns. All other goroutines are stuck trying to send their results. This means if you have more than one replica each call will leak resources.</p> <p>To avoid the leaks you need to make sure all goroutines exit. One potential solution is to use a buffered result channel big enough to hold all results.</p> <pre><code>func First(query string, replicas ...Search) Result {\n    c := make(chan Result,len(replicas))\n    searchReplica := func(i int) { c &lt;- replicas[i](query) }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n    return &lt;-c\n}\n</code></pre> <p>Another potential solution is to use a <code>select</code> statement with a <code>default</code> case and a buffered result channel that can hold one value. The <code>default</code> case ensures that the goroutines don't get stuck even when the result channel can't receive messages.</p> <pre><code>func First(query string, replicas ...Search) Result {\n    c := make(chan Result,1)\n    searchReplica := func(i int) {\n        select {\n        case c &lt;- replicas[i](query):\n        default:\n        }\n    }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n    return &lt;-c\n}\n</code></pre> <p>You can also use a special cancellation channel to interrupt the workers.</p> <pre><code>func First(query string, replicas ...Search) Result {\n    c := make(chan Result)\n    done := make(chan struct{})\n    defer close(done)\n    searchReplica := func(i int) {\n        select {\n        case c &lt;- replicas[i](query):\n        case &lt;- done:\n        }\n    }\n    for i := range replicas {\n        go searchReplica(i)\n    }\n\n    return &lt;-c\n}\n</code></pre> <p>Why did the presentation contain these bugs? Rob Pike simply didn't want to comlicate the slides. It makes sense, but it can be a problem for new Go developers who would use the code as is without thinking that it might have problems.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#same-address-for-different-zero-sized-variables","title":"Same Address for Different Zero-sized Variables","text":"<p>\u2192 intermediate</p> <p>If you have two different variables shouldn't they have different addresses? Well, it's not the case with Go :-) If you have zero-sized variables they might share the exact same address in memory.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n)\n\ntype data struct {\n}\n\nfunc main() {\n  a := &amp;data{}\n  b := &amp;data{}\n\n  if a == b {\n    fmt.Printf(\"same address - a=%p b=%p\\n\",a,b)\n    //prints: same address - a=0x1953e4 b=0x1953e4\n  }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#the-first-use-of-iota-doesnt-always-start-with-zero","title":"The First Use of iota Doesn't Always Start with Zero","text":"<p>\u2192 intermediate</p> <p>It may seem like the <code>iota</code> identifyer is like an increment operator. You start a new constant declaration and the first time you use <code>iota</code> you get zero, the second time you use it you get one and so on. It's not always the case though.</p> <pre><code>package main\n\nimport (\n  \"fmt\"\n)\n\nconst (\n  azero = iota\n  aone  = iota\n)\n\nconst (\n  info  = \"processing\"\n  bzero = iota\n  bone  = iota\n)\n\nfunc main() {\n  fmt.Println(azero,aone) //prints: 0 1\n  fmt.Println(bzero,bone) //prints: 1 2\n}\n</code></pre> <p>The <code>iota</code> is really an index operator for the current line in the constant declaration block, so if the first use of <code>iota</code> is not the first line in the constant declaration block the initial value will not be zero.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#using-pointer-receiver-methods-on-value-instances","title":"Using Pointer Receiver Methods On Value Instances","text":"<p>\u2192 advanced</p> <p>It's OK to call a pointer receiver method on a value as long as the value is addressable. In other words, you don't need to have a value receiver version of the method in some cases.</p> <p>Not every variable is addressable though. Map elements are not addressable. Variables referenced through interfaces are also not addressable.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    name string\n}\n\nfunc (p *data) print() {\n    fmt.Println(\"name:\",p.name)\n}\n\ntype printer interface {\n    print()\n}\n\nfunc main() {\n    d1 := data{\"one\"}\n    d1.print() //ok\n\n    var in printer = data{\"two\"} //error\n    in.print()\n\n    m := map[string]data {\"x\":data{\"three\"}}\n    m[\"x\"].print() //error\n}\n</code></pre> <p>Compile Errors:</p> <p>/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment:       data does not implement printer (print method has pointer receiver)   /tmp/sandbox017696142/main.go:25: cannot call pointer method on m[\"x\"]   /tmp/sandbox017696142/main.go:25: cannot take the address of m[\"x\"] </p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#updating-map-value-fields","title":"Updating Map Value Fields","text":"<p>\u2192 advanced</p> <p>If you have a map of struct values you can't update individual struct fields.</p> <p>Fails:</p> <pre><code>package main\n\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]data {\"x\":{\"one\"}}\n    m[\"x\"].name = \"two\" //error\n}\n</code></pre> <p>Compile Error:</p> <p>/tmp/sandbox380452744/main.go:9: cannot assign to m[\"x\"].name </p> <p>It doesn't work because map elements are not addressable. What can be extra confusing for new Go devs is the fact that slice elements are addressable.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    name string\n}\n\nfunc main() {\n    s := []data {{\"one\"}}\n    s[0].name = \"two\" //ok\n    fmt.Println(s)    //prints: [{two}]\n}\n</code></pre> <p>Note that a while ago it was possible to update map element fields in one of the Go compilers (gccgo), but that behavior was quickly fixed :-) It was also considered as a potential feature for Go 1.3. It wasn't important enough to support at that point in time, so it's still on the todo list. The first work around is to use a temporary variable.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]data {\"x\":{\"one\"}}\n    r := m[\"x\"]\n    r.name = \"two\"\n    m[\"x\"] = r\n    fmt.Printf(\"%v\",m) //prints: map[x:{two}]\n}\n</code></pre> <p>Another workaround is to use a map of pointers.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]*data {\"x\":{\"one\"}}\n    m[\"x\"].name = \"two\" //ok\n    fmt.Println(m[\"x\"]) //prints: &amp;{two}\n}\n</code></pre> <p>By the way, what happens when you run this code?</p> <pre><code>package main\n\ntype data struct {\n    name string\n}\n\nfunc main() {\n    m := map[string]*data {\"x\":{\"one\"}}\n    m[\"z\"].name = \"what?\" //???\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#nil-interfaces-and-nil-interfaces-values","title":"\"nil\" Interfaces and \"nil\" Interfaces Values","text":"<p>\u2192 advanced</p> <p>This is the second most common gotcha in Go because interfaces are not pointers even though they may look like pointers. Interface variables will be \"nil\" only when their type and value fields are \"nil\".</p> <p>The interface type and value fields are populated based on the type and value of the variable used to create the corresponding interface variable. This can lead to unexpected behavior when you are trying to check if an interface variable equals to \"nil\".</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var data *byte\n    var in interface{}\n\n    fmt.Println(data,data == nil) //prints: &lt;nil&gt; true\n    fmt.Println(in,in == nil)     //prints: &lt;nil&gt; true\n\n    in = data\n    fmt.Println(in,in == nil)     //prints: &lt;nil&gt; false\n    //'data' is 'nil', but 'in' is not 'nil'\n}\n</code></pre> <p>Watch out for this trap when you have a function that returns interfaces.</p> <p>Incorrect:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    doit := func(arg int) interface{} {\n        var result *struct{} = nil\n\n        if(arg &gt; 0) {\n            result = &amp;struct{}{}\n        }\n\n        return result\n    }\n\n    if res := doit(-1); res != nil {\n        fmt.Println(\"good result:\",res) //prints: good result: &lt;nil&gt;\n        //'res' is not 'nil', but its value is 'nil'\n    }\n}\n</code></pre> <p>Works:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    doit := func(arg int) interface{} {\n        var result *struct{} = nil\n\n        if(arg &gt; 0) {\n            result = &amp;struct{}{}\n        } else {\n            return nil //return an explicit 'nil'\n        }\n\n        return result\n    }\n\n    if res := doit(-1); res != nil {\n        fmt.Println(\"good result:\",res)\n    } else {\n        fmt.Println(\"bad result (res is nil)\") //here as expected\n    }\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#stack-and-heap-variables","title":"Stack and Heap Variables","text":"<p>\u2192 advanced</p> <p>You don't always know if your variable is allocated on the stack or heap. In C++ creating variables using the <code>new</code> operator always means that you have a heap variable. In Go the compiler decides where the variable will be allocated even if the <code>new()</code> or <code>make()</code> functions are used. The compiler picks the location to store the variable based on its size and the result of \"escape analysis\". This also means that it's ok to return  references to local variables, which is not ok in other languages like C or C++.</p> <p>If you need to know where your variables are allocated pass the \"-m\" gc flag to \"go build\" or \"go run\" (e.g., <code>go run -gcflags -m app.go</code>).</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#gomaxprocs-concurrency-and-parallelism","title":"GOMAXPROCS, Concurrency, and Parallelism","text":"<p>\u2192 advanced</p> <p>Go 1.4 and below uses only one execution context / OS thread. This means that only one goroutine can execute at any given time. Starting with 1.5 Go sets the number of execution contexts to the number of logical CPU cores returned by <code>runtime.NumCPU()</code>. That number may or may not match the total number of logical CPU cores on your system depending on the CPU affinity settings of your process.  You can adjust this number by changing the <code>GOMAXPROCS</code> environment variable or by calling the <code>runtime.GOMAXPROCS()</code> function.</p> <p>There's a common misconception that <code>GOMAXPROCS</code> represents the number of CPUs Go will use to run goroutines. The <code>runtime.GOMAXPROCS()</code> function documentation adds more to the confusion. The <code>GOMAXPROCS</code> variable description (https://golang.org/pkg/runtime/) does a better job talking about OS threads.</p> <p>You can set <code>GOMAXPROCS</code> to more than the number of your CPUs. As of 1.10 there's no longer a limit for GOMAXPROCS. The max value for <code>GOMAXPROCS</code> used to be 256 and it was later increased to 1024 in 1.9.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: X (1 on play.golang.org)\n    fmt.Println(runtime.NumCPU())       //prints: X (1 on play.golang.org)\n    runtime.GOMAXPROCS(20)\n    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 20\n    runtime.GOMAXPROCS(300)\n    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 256\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#read-and-write-operation-reordering","title":"Read and Write Operation Reordering","text":"<p>\u2192 advanced</p> <p>Go may reorder some operations, but it ensures that the overall behavior in the goroutine where it happens doesn't change. However, it doesn't guarantee the order of execution across multiple goroutines.</p> <pre><code>package main\n\nimport (\n    \"runtime\"\n    \"time\"\n)\n\nvar _ = runtime.GOMAXPROCS(3)\n\nvar a, b int\n\nfunc u1() {\n    a = 1\n    b = 2\n}\n\nfunc u2() {\n    a = 3\n    b = 4\n}\n\nfunc p() {\n    println(a)\n    println(b)\n}\n\nfunc main() {\n    go u1()\n    go u2()\n    go p()\n    time.Sleep(1 * time.Second)\n}\n</code></pre> <p>If you run this code a few times you might see these <code>a</code> and <code>b</code> variable combinations:</p> <p>1      2</p> <p>3      4</p> <p>0      2</p> <p>0      0</p> <p>1      4 </p> <p>The most interesting combination for <code>a</code> and <code>b</code> is \"02\". It shows that <code>b</code> was updated before <code>a</code>.</p> <p>If you need to preserve the order of read and write operations across multiple goroutines you'll need to use channels or the appropriate constructs from the \"sync\" package.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#preemptive-scheduling","title":"Preemptive Scheduling","text":"<p>\u2192 advanced</p> <p>It's possible to have a rogue goroutine that prevents other goroutines from running. It can happen if you have a <code>for</code> loop that doesn't allow the scheduler to run.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    done := false\n\n    go func(){\n        done = true\n    }()\n\n    for !done {\n    }\n    fmt.Println(\"done!\")\n}\n</code></pre> <p>The <code>for</code> loop doesn't have to be empty. It'll be a problem as long as it contains code that doesn't trigger the scheduler execution.</p> <p>The scheduler will run after GC, \"go\" statements, blocking channel operations, blocking system calls, and lock operations. It may also run when a non-inlined function is called.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    done := false\n\n    go func(){\n        done = true\n    }()\n\n    for !done {\n        fmt.Println(\"not done!\") //not inlined\n    }\n    fmt.Println(\"done!\")\n}\n</code></pre> <p>To find out if the function you call in the <code>for</code> loop is inlined pass the \"-m\" gc flag to \"go build\" or \"go run\" (e.g., <code>go build -gcflags -m</code>).</p> <p>Another option is to invoke the scheduler explicitly. You can do it with the <code>Gosched()</code> function from the \"runtime\" package.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    done := false\n\n    go func(){\n        done = true\n    }()\n\n    for !done {\n        runtime.Gosched()\n    }\n    fmt.Println(\"done!\")\n}\n</code></pre> <p>Note that the code above contains a race condition. It was done intentionally to show the sheduling gotcha.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#import-c-and-multiline-import-blocks","title":"Import C and Multiline Import Blocks","text":"<p>\u2192 Cgo</p> <p>You need to import the \"C\" package to use Cgo. You can do that with a single line <code>import</code> or you can do it with an <code>import</code> block.</p> <pre><code>package main\n\n/*\n#include &lt;stdlib.h&gt;\n*/\nimport (\n  \"C\"\n)\n\nimport (\n  \"unsafe\"\n)\n\nfunc main() {\n  cs := C.CString(\"my go string\")\n  C.free(unsafe.Pointer(cs))\n}\n</code></pre> <p>If you are using the <code>import</code> block format you can't import other packages in the same block.</p> <pre><code>package main\n\n/*\n#include &lt;stdlib.h&gt;\n*/\nimport (\n  \"C\"\n  \"unsafe\"\n)\n\nfunc main() {\n  cs := C.CString(\"my go string\")\n  C.free(unsafe.Pointer(cs))\n}\n</code></pre> <p>Compile Error:</p> <p>./main.go:13:2: could not determine kind of name for C.free </p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#no-blank-lines-between-import-c-and-cgo-comments","title":"No blank lines Between Import C and Cgo Comments","text":"<p>\u2192 Cgo</p> <p>One of the first gotchas with Cgo is the location of the cgo comments above the <code>import \"C\"</code> statement.</p> <pre><code>package main\n\n/*\n#include &lt;stdlib.h&gt;\n*/\n\nimport \"C\"\n\nimport (\n  \"unsafe\"\n)\n\nfunc main() {\n  cs := C.CString(\"my go string\")\n  C.free(unsafe.Pointer(cs))\n}\n</code></pre> <p>Compile Error:</p> <p>./main.go:15:2: could not determine kind of name for C.free </p> <p>Make sure you don't have any blank lines above <code>import \"C\"</code> statement.</p>","tags":["golang","common mistakes"]},{"location":"Golang/common-pitfalls.html#cant-call-c-functions-with-variable-arguments","title":"Can't Call C Functions with Variable Arguments","text":"<p>\u2192 Cgo</p> <p>You can't call C functions with variable arguments directly.</p> <pre><code>package main\n\n/*\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n*/\nimport \"C\"\n\nimport (\n  \"unsafe\"\n)\n\nfunc main() {\n  cstr := C.CString(\"go\")\n  C.printf(\"%s\\n\",cstr) //not ok\n  C.free(unsafe.Pointer(cstr))\n}\n</code></pre> <p>Compile Error:</p> <p>./main.go:15:2: unexpected type: ... </p> <p>You have to wrap your variadic C functions in functions with a known number of parameters.</p> <pre><code>package main\n\n/*\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid out(char* in) {\n  printf(\"%s\\n\", in);\n}\n*/\nimport \"C\"\n\nimport (\n  \"unsafe\"\n)\n\nfunc main() {\n  cstr := C.CString(\"go\")\n  C.out(cstr) //ok\n  C.free(unsafe.Pointer(cstr))\n}\n</code></pre>","tags":["golang","common mistakes"]},{"location":"Golang/http-error-handler.html","title":"HTTP Error Handling in golang","text":"<p>Golang have excellent http library built in but it does not offer returning error for convient use case.  where other router like echo does offer error returing handler. now in this post we are going to look at creating http error returning handler. how create how to execute it.</p>"},{"location":"Golang/http-error-handler.html#creating-custom-http-handler","title":"Creating custom http handler","text":"<p>What is http handler in go or rather what is <code>http.HandlerFunc</code> is? In simple term http.HandlerFunc is whatever that implements <code>ServeHTTP(w http.ResponseWriter, r *http.Request)</code>. See subsequent snippet to follow how we are creating custom handler which returns error.</p> <pre><code>package main\n\nimport (\n    \"http\"\n    \"errors\"\n)\n\ntype HandlerFunc func(w http.ResponseWriter, r *http.Request) error\n\nfunc (h HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := h(w, r); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)          \n        return\n    }\n}\n\nfunc main() {\n    mux := http.NewServeMux()\n    mux.Handle(\"/\", HandlerFunc(func(w http.ResponseWriter, r *http.Request) error {\n        return errors.New(\"this is error\")\n    }))\n    http.ListenAndServe(\":3000\", mux)\n}\n</code></pre> <ul> <li>On line number 10 we implmented ServeHTTP method on our handler function</li> <li>Line number 11 executes our incoming handler and reurns any error from it</li> <li>On line 19 we converted <code>http.HandlerFunc</code> to our custom <code>HandlerFunc</code></li> </ul> <p>notice that this type of error handling now we can't specifiy status code and serve http will always return 500 as status. we will look at how to tackle it in next section.</p>"},{"location":"Golang/http-error-handler.html#creating-custom-error-for-better-response","title":"Creating custom error for better response","text":"<ul> <li>Basic idea here is we will create struct that implments both error and Marshler interfaces. </li> <li>We need to implement Marsheler as golang doesn't know how to json encode errors</li> <li>Notice in MarshalJSON method we are returning custom struct with all field exported to encode json.</li> </ul> <pre><code>type AppErr struct {\n    err    error\n    msg    string\n    status int\n}\n\nfunc HTTPError(e error, m string, code int) AppErr {\n    return AppErr{e, m, code}\n}\n\nfunc (e AppErr) Unwrap() error {\n    return e.err\n}\n\nfunc (e AppErr) Error() string {\n    return e.err.Error()\n}\n\nfunc (e AppErr) MarshalJSON() ([]byte, error) {\n    return json.Marshal(struct {\n        Err        string `json:\"err,omitempty\"`\n        Msg        string `json:\"msg,omitempty\"`\n        StatusCode int    `json:\"status_code,omitempty\"`\n    }{\n        e.Error(), e.msg, e.status,\n    })\n}\n</code></pre>"},{"location":"Golang/http-error-handler.html#changing-our-servehttp-to-handle-custom-error","title":"Changing our ServeHTTP to handle custom error","text":"<pre><code>type HandlerFunc func(w http.ResponseWriter, r *http.Request) error\n\nfunc (h HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := h(w, r); err != nil {\n        if errors.As(err, &amp;AppErr{}) {\n            e := err.(AppErr)\n            fmt.Println(err)\n            JSON(w, e.status, e, map[string]string{\"Content-Type\": \"application/json\"})\n        }\n        return\n    }\n}\n</code></pre>"},{"location":"Golang/http-error-handler.html#complete-code","title":"Complete Code","text":"<pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"net/http\"\n)\n\n// JSON is repsonse helper functions\nfunc JSON(w http.ResponseWriter, code int, payload any, headers map[string]string) error {\n    for k, v := range headers {\n        w.Header().Set(k, v)\n    }\n    w.WriteHeader(code)\n    return json.NewEncoder(w).Encode(payload)\n}\n\n// Bind binds the request body to given model\nfunc Bind[M any](r *http.Request) (M, error) {\n    var m M\n    return m, json.NewDecoder(r.Body).Decode(&amp;m)\n}\n\n// Custom Handler func that Defines error on top of http.HandlerFunc\ntype HandlerFunc func(w http.ResponseWriter, r *http.Request) error\n\nfunc (h HandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := h(w, r); err != nil {\n        if errors.As(err, &amp;AppErr{}) {\n            e := err.(AppErr)\n            fmt.Println(err)\n            JSON(w, e.status, e, map[string]string{\"Content-Type\": \"application/json\"})\n        }\n        return\n    }\n}\n\n// app err which implments custom\n// JsonMarshaler and Error interface\ntype AppErr struct {\n    err    error\n    msg    string\n    status int\n}\n\nfunc HTTPError(e error, m string, code int) AppErr {\n    return AppErr{e, m, code}\n}\n\nfunc (e AppErr) Unwrap() error {\n    return e.err\n}\n\nfunc (e AppErr) Error() string {\n    return e.err.Error()\n}\n\nfunc (e AppErr) MarshalJSON() ([]byte, error) {\n    return json.Marshal(struct {\n        Err        string `json:\"err,omitempty\"`\n        Msg        string `json:\"msg,omitempty\"`\n        StatusCode int    `json:\"status_code,omitempty\"`\n    }{\n        e.Error(), e.msg, e.status,\n    })\n}\n\n// api struct\ntype API struct {\n    router *http.ServeMux\n}\n\nfunc (api *API) GetE(w http.ResponseWriter, r *http.Request) error {\n    return HTTPError(errors.New(\"this is error\"), \"just error\", 400)\n}\n\nfunc (api *API) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    api.router.ServeHTTP(w, r)\n}\n\nfunc (api *API) Routes() {\n    api.router.Handle(\"/\", HandlerFunc(api.GetE))\n}\n\nfunc main() {\n    mux := http.NewServeMux()\n    api := &amp;API{mux}\n    api.Routes()\n    srv := &amp;http.Server{\n        Addr:    \":8080\",\n        Handler: api,\n    }\n    srv.ListenAndServe()\n}\n</code></pre>"},{"location":"Golang/tutorial/advanced.html","title":"Advanced","text":"","tags":["golang","advanced","guides"]},{"location":"Golang/tutorial/advanced.html#time","title":"Time","text":"<ul> <li>go has std lib package time which use to handle date and time.</li> <li>to format time string you can use time.Format(\"\") and mention format of string like below \u2192 <pre><code>// Day of the month: \"2\" \"_2\" \"02\" \n// Day of the week: \"Mon\" \"Monday\"\n// Month: \"Jan\" \"January\" \"01\" \"1\"\n// Year: \"2006\" \"06\"\n// Day of the year: \"__2\" \"002\"\n// Hour: \"15\" \"3\" \"03\" (PM or AM)\n// Minute: \"04\"\n// Second: \"05\"\n// Miliseconds: \"05\"\n// AM/PM mark: \"PM\"\n// TimeZone: \"MST\" \"-0700\"\nfmt.Println(time.Now().Format(\"2006 Jan 02 03:04 PM\"))\nfmt.Println(time.Now().Format(\"02-01-2006 15:04:05 MST\"))\nfmt.Println(time.Now().Format(\"02-01-2006T15:04:05TZ-0700\"))\n\n// or you can use rfc standard\nfmt.Println(time.Now().Format(time.RFC3339))\n\n// output\n// 2022 Aug 22 01:43 PM\n</code></pre></li> <li>parsing the datetime string into object <pre><code>// converting time string to Time object\nparsedTime, err := time.Parse(\"02/01/2006 15:04\", \"06/02/1997 09:15\")\nif err != nil {\n    fmt.Println(err)\n}\nfmt.Println(parsedTime.Format(\"02 Jan 2006 09:15PM\"))\n//output\n// 06 Feb 1997 09:09AM\n</code></pre></li> </ul>","tags":["golang","advanced","guides"]},{"location":"Golang/tutorial/basics.html","title":"Basics","text":"","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#basic-info","title":"Basic Info","text":"<ol> <li>Go programs are made up of packages</li> <li>Execution of program starts from <code>main()</code> function in <code>main</code> package.</li> <li>Example <code>math/rand</code> comprises of files that starts with <code>package rand</code> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, World!\")        \n}\n</code></pre></li> </ol> <ul> <li> <p>use parenthesized import statement for multiple imports <pre><code>package main\n\nimport (\n    \"math/rand\"\n    \"fmt\"\n)\n</code></pre></p> </li> <li> <p>Exporting \u2192 Everything which starts from capital letter is exportable in go. all remaining are accessible at package level . <pre><code>package greeter\n\n// greet is only accessible inside greet package\nfunc greet(name string) string {\n    return \"Hello \" + name\n}\n\n// GreetBomb can be accessed outside greet package\nfunc GreetBomb() {\n    for {\n        fmt.Println(\"Hello unilimited\")\n    }\n}\n</code></pre></p> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#how-to-execute","title":"How to execute","text":"<ul> <li>Execution of program starts from <code>main()</code> function in main package</li> <li>There should be only one <code>main.go</code> file in single project.</li> <li>To run use command <code>go run main.go</code></li> <li>To build use command <code>go build .</code></li> </ul> <p>note: in order to use build command you should initialize go-modules for project directory</p>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#variables","title":"Variables","text":"<ul> <li>you can declare variables like <code>var name string</code> or <code>var name = \"qwerty\"</code> or <code>name := \"qwerty\"</code>.</li> <li>you can also declare multiple variables on same line using wallrus(:=) operator <code>a,b := 1,2</code></li> <li>There are local and global variables local are bound the scope of block or function. global variables are accessible through out the package.</li> </ul> <p>Warning</p> <p>global variables cannot be declared by wallrus operator</p>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#data-types","title":"Data Types","text":"<ul> <li>everything in go is type just like everything in python is object.</li> <li>go provide basic types such as integer, float, boolean, string, byte, rune, complex</li> <li><code>integer</code> is further devided into int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64.<ul> <li><code>int</code> and <code>uint</code> are atleast 32 bit in nature but not alias for int32 or uint32 it can also be 64 bit depending upon operatinf system.</li> </ul> </li> <li><code>floats</code> can be declare as float32(4 bytes), float64(8 bytes) default float type inferred is float64.</li> <li><code>complex</code> number are 2 types complex64 and complex128 default is complex128.</li> <li><code>byte</code> is alias for uint8.</li> <li><code>rune</code> is alias for int32. integer value is meant to represent unicode code point. unicode code reprents character like U+0030 but it doesn't know how to save it. this is where utf-8 comes in picture utf-8 saves character using 1,2,3,4 bytes ascii representation are saved using 1 byte. that's why rune is int32 so maximum storage length of utf-8 is 4 bytes and every string in go is encoded using utf-8. you can read more about unicode in this blog https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/</li> <li><code>string</code> is slice of bytes and can be declare using double qoutes which respects escape sequence while raw string does not.</li> <li><code>boolean</code> \u2192 <code>OR ||</code> <code>AND &amp;&amp;</code> <code>NEGATION !</code></li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#control-flow","title":"Control flow","text":"<ul> <li>Go provide control flow statement such as if - else, switch, for loop.</li> <li> <p>Brackets in Go if else around the condition are omitted. <pre><code>if condition {\n   //Do something\n} else if condition {\n   //Do something\n} else {\n   //Do something\n</code></pre></p> </li> <li> <p>short statement can also be used such as assigning and putting condition on it. <pre><code>if statement; condition {\n   //Do something\n}\n</code></pre></p> </li> <li> <p>switch statement <pre><code>switch statement; expression {\ncase expression1:\n    //Dosomething\ncase expression2:\n     //Dosomething\ndefault:\n     //Dosomething\n}\n</code></pre></p> </li> <li> <p>for loop \u2192 init and post part are optional remove them and you will get while loop. remove all and get while loop infinity. use <code>continue</code> and <code>break</code> keyword to continue and break flow of loop respectively. use range keyword to get iterator dynamically <pre><code>package main\n\nimport \"fmt\"\n\n// loops in golang\n// golang only provide for loop\nfunc loop() {\n    count := 5\n    // normal loop\n    for i := 0; i &lt; count; i++ {\n        fmt.Println(i)\n    }\n    // while loop\n    i := 0\n    for i &lt; count {\n        fmt.Println(i)\n        i++\n    }\n    // infinte while loop\n    count = 0\n    for {\n        if count &gt; 4 {\n            break\n        }\n        fmt.Println(count)\n        count++\n    }\n    // range loop\n    names := []string{\"alexa\", \"google homes\", \"siri\", \"cortana\"}\n    for idx, val := range names {\n        fmt.Printf(\"index - %v value - %v\\n\", idx, val)\n    }\n}\n</code></pre></p> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#functions","title":"Functions","text":"<ul> <li> <p>basic function in golang <pre><code>func fn() {\n    fmt.Println(\"simple function\")\n}\n</code></pre></p> </li> <li> <p>function with paramters <pre><code>func fn(name string) {\n    fmt.Println(name)   \n}\n</code></pre></p> </li> <li> <p>function with varidaic parameters <pre><code>func fn(nums ...int) {\n    sum := 0\n    for i:=0;i&lt;len(nums);i++{\n        sum += nums[i]\n    }\n    fmt.Println(sum)\n}\n</code></pre></p> </li> <li> <p>closure or inline function in go. It can also be assigned to variable <pre><code>func fn() {\n    // closure\n    func() {\n        fmt.Println(\"Closure\")\n    }()\n    // closure with params\n    func(nums ...int) {\n        sum := 0\n        for _, i := range nums {\n            sum += i\n        }\n        fmt.Println(sum)\n    }(5, 6, 7, 8)\n}\n</code></pre></p> </li> <li> <p>function with return type and return name and type declared <pre><code>// function with multiple return type and arguments\nfunc getNames(name1, name2 string) (string, string) {\n    return strings.ToTitle(name1), strings.ToUpper(name2)\n}\n\n// function with return variable mentioned\nfunc returnMentioned() (count int) {\n    count = 10\n    return\n}\n</code></pre></p> </li> <li> <p><code>init</code> function</p> </li> <li>executes before main function and use cases include initilizing some value or configuration at runtime</li> <li>each  package have there own init function <pre><code>package main\n\nfunc main(){\n    fmt.Println(\"main function\")\n}\n\nfunc init(){\n    fmt.Println(\"init function\")\n}\n\n//output\n// Init function\n// main function\n</code></pre></li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#errors","title":"Errors","text":"<ul> <li>Go\u2019s way of dealing with an error is to explicitly return the error as a separate value</li> <li> <p>you can check if returned error value from function is nil or not for error checking <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.Open(\"non-existing.txt\")\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(file.Name() + \"opened succesfully\")\n    }\n}\n</code></pre></p> </li> <li> <p>custom error can be defiened using <code>errors.New(\"error something occurred\")</code></p> </li> <li>custom error with formatted message <code>fmt.Errorf(\"Err is: %s\", \"database connection issue\")</code></li> <li>advanced custom error messages<ul> <li>in below program <code>inputError</code> is a type of struct which implements the <code>Error()</code> interface method.</li> <li>and <code>missingField</code> is addtional field in <code>inputError</code> to provide more information about error along with it\u2019s method called <code>getMissingField</code>.</li> <li>lastly <code>validate()</code> function will return <code>pointer to inputError that can be nil</code> and <code>advancedCustomError()</code> will type assert error and get the missing field name. <pre><code>// advanced custom error message\nfunc advancedCustomError() {\n    err := validate(\"\", \"\")\n    if err != nil {\n        if err, ok := err.(*inputError); ok {\n            fmt.Println(err)\n            fmt.Printf(\"Missing Field is %s\\n\", err.getMissingField())\n        }\n    }\n}\n\n// function that return struct which implements Error() interface method\nfunc validate(name, gender string) error {\n    if name == \"\" {\n        return &amp;inputError{message: \"Name is mandatory\", missingField: \"name\"}\n    }\n    if gender == \"\" {\n        return &amp;inputError{message: \"Gender is mandatory\", missingField: \"gender\"}\n    }\n    return nil\n}\n\n// struct type for holding value\ntype inputError struct {\n    message      string\n    missingField string\n}\n\n// impleneting error interface\nfunc (i *inputError) Error() string {\n    return i.message\n}\n\n// addtional method for performing necessary action\nfunc (i *inputError) getMissingField() string {\n    return i.missingField\n}\n</code></pre></li> </ul> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#panic-and-recover","title":"Panic and recover","text":"<ul> <li>you can wrap error using  <code>fmt.Errorf(\"E2: %w\", e1)</code> %w is used to wrap an error.</li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#defer-keyword","title":"Defer keyword","text":"<ul> <li>defer keyword send any execution to end of function</li> <li>deferred function always execute even if surrounding function execution failed abrruptly.</li> <li>deferred function will execute before surrounding function returns.</li> <li>mutliple defer keyword execute last in first out order <pre><code>package main\nimport \"fmt\"\nfunc main() {\n    i := 0\n    i = 1\n    defer fmt.Println(i)\n    i = 2\n    defer fmt.Println(i)\n    i = 3\n    defer fmt.Println(i)\n}\n// output\n// 3\n// 2\n// 1\n</code></pre></li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#pointers","title":"Pointers","text":"<ul> <li>pointer declaration <code>var sptr *string</code></li> <li>pointer can be initialized uisng two way one is <code>sptr = new(\"alex\")</code> and second is <code>sptr = &amp;name</code></li> <li>for priting the value of pointer you can use astricks operator before variable name <code>*sptr</code> effectively dereferencing it.</li> <li>below is the image of pointer deferencing \u2192</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc pointers() {\n    // declaration of pointer\n    var sptr *string\n    name := \"Jayesh\"\n    sptr = &amp;name\n    var ssptr **string = &amp;sptr\n    fmt.Println(\"original variable:\", name)\n    fmt.Println(\"pointer adress:\", sptr)\n    fmt.Println(\"referenced variable value:\", *sptr)\n    fmt.Println(\"double refernced ssptr:\", ssptr)\n    fmt.Println(\"ssptr value to original pointer:\", *ssptr)\n    fmt.Println(\"actual ssptr point value derefrenced:\", **ssptr)\n}\n\n// output\n//WARN: this addresses may changes on your system\noriginal variable: Jayesh\npointer adress: 0xc00004c230\nreferenced variable value: Jayesh\ndouble refernced ssptr: 0xc00000e028\nssptr value to original pointer: 0xc00004c230\nactual ssptr point value derefrenced: Jayesh\n</code></pre>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#structs","title":"Structs","text":"<ul> <li>struct is collection of fields.</li> <li>member of struct can be accessed by dot notation</li> <li>struct are pass by value by default.<ul> <li>if you pass struct to function or new variable a copy of struct is passed</li> <li>to manage struct state they need to be pass by reference (pointers)</li> </ul> </li> <li>structs can be nested.</li> <li>nested field are also accessed by dot notation <pre><code>// simple struct\ntype employee struct {\n    name   string\n    age    int\n    salary int\n}\n// nested struct\ntype employee struct {\n    name   string\n    age    int\n    salary int\n    company employer\n}\ntype employer struct {\n    name   string\n    location string\n}\n</code></pre></li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#slices","title":"Slices","text":"<ul> <li> <p>slices in golang represents three follwing things \u2192</p> <ul> <li>pointer to underlying array \u2192<code>always pass by reference</code></li> <li>current lenght of underlying array \u2192<code>len()</code></li> <li>total capacity which is the maximum capacity to which the underlying array can expand \u2192 <code>cap()</code> <pre><code>type SliceHeader struct {\n        Pointer uintptr\n        Len  int\n        Cap  int\n}\n</code></pre> </li> </ul> </li> <li> <p>default value of slice is usable.</p> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#maps","title":"Maps","text":"<ul> <li>default nil value of map cannot be used.</li> <li>allowed key types are \u2192<ul> <li>boolean</li> <li>numeric</li> <li>string</li> <li>pointer</li> <li>channel</li> <li>interface types</li> <li>structs \u2013 if all it\u2019s field type is comparable</li> <li>array \u2013 if the type of value of array element is comparable</li> </ul> </li> <li>not alllowed key types \u2192<ul> <li>Slice</li> <li>Map</li> <li>Function</li> </ul> </li> <li> <p>if there are duplicate key the recent value for key is considerd and previous value is discarded <pre><code>salary := map[string]int{\"manoj\": 2000}\n    salary[\"manoj\"] = 3000\n    salary[\"nitin\"] = 1000\n    fmt.Println(\"salary map:\", salary)\n\n// output\nsalary map: map[manoj:3000 nitin:1000]\n</code></pre></p> </li> <li> <p>you can iterate over map using for range loop <pre><code>for k, v := range salary{\n    fmt.Printf(\"key: %v, value: %v\\n\", k,v)\n}\n</code></pre></p> </li> <li> <p>map are refrenced data type and is not safe for concurrent use. two variable assigned to each other containing map will point to same map and changes will be reflected wise versa. <pre><code>func main(){\n    user := map[string]string{\n        \"name\":       \"John wick\",\n        \"profession\": \"assasination\",\n    }\n    fmt.Println(\"original -&gt; \", user)\n    mapPassed(user)\n    fmt.Println(\"modified -&gt; \", user)\n}\n\n// changes to map will reflect to in parent function to\nfunc mapPassed(user map[string]string) {\n    user[\"status\"] = \"rich\"\n}\n// output\n// map[name:John wick profession:assasination]\n// map[name:John wick profession:assasination status:rich]\n</code></pre></p> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#methods","title":"Methods","text":"<ul> <li>methods are receiver function on specific type, eg struct or other function or interface.</li> <li>methods can access properties of receiver and other methods on that type.</li> <li> <p>basics syntax <code>func (receiver receiver_type) some_func_name(arguments) return_values</code>. <pre><code>type user struct {\n    id          int\n    name        string\n    email       string\n    password    string\n    description string\n}\n\n// method syntax func (receiver receiver_type) some_func_name(arguments) return_values\nfunc (u *user) validate() error {\n    switch {\n    case !strings.Contains(u.email, \"@\"):\n        return errors.New(\"enter proper mail format\")\n    case len(u.password) &lt; 8:\n        return errors.New(\"password should be greater than 8 characters\")\n    case u.description == \"\":\n        return errors.New(\"descrition should not be empty\")\n    }\n    return nil\n}\n</code></pre></p> </li> <li> <p>methods on function type <pre><code>type Greeting func(name string) string\n\nfunc (g Greeting) exclamation(name string) string {\n    return g(name) + \"!\"\n}\n\nfunc (g Greeting) upper(name string) {\n    fmt.Println(strings.ToUpper(name))\n}\n\nfunc main() {\n    english := Greeting(func(name string) string {\n        return \"Hello, \" + name\n    })\n    fmt.Println(english(\"ANisus\"))\n    fmt.Println(english.exclamation(\"ANisus\"))\n    english.upper(\"ANisus\")\n}\n</code></pre></p> </li> </ul>","tags":["golang","basics","guides"]},{"location":"Golang/tutorial/basics.html#interfaces","title":"Interfaces","text":"<ul> <li> <p>basic syntax <pre><code>type interface_name interface{\n    method_name(argument_name argument_type) returnvalues and types \n}\n\n// example\ntype animal interface {\n    breathe()\n    walk()\n}\n</code></pre></p> </li> <li> <p>default value of interface is nil.</p> </li> <li>Interface are implemented implicitly</li> <li>Helps write more modular and decoupled code between different parts of codebase \u2013 It can help reduce dependency between different parts of codebase and provide loose coupling this is application of interface.</li> <li>A type implements an interface if it defines all methods of an interface. If that defines all methods of another interface then it implements that interface. In essence, a type can implement multiple interfaces.</li> </ul> <p></p> <ul> <li>type asserting syntax <code>val := i.({type})</code></li> <li>to get concret value of interface type assertion is used in golang.</li> <li>An empty interface has no methods , hence by default all concrete types implement the empty interface. If you write a function that accepts an empty interface then you can pass any type to that function</li> </ul>","tags":["golang","basics","guides"]},{"location":"K8s/getting-started.html","title":"Getting Started","text":"<p>For learning purpose we are using minikube to mimic single cluster on our local system. feel free to use kind or k3s For development purpose. and testing things out on local system</p>"},{"location":"K8s/getting-started.html#installation-of-minikube","title":"installation of minikube","text":"<p>if you're on arch linux you can directly fire command <code>sudo pacman -S minikube</code> if not you do following. </p> <pre><code>curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; rm minikube-linux-amd64\n</code></pre> <p>Setting Up \u2192</p> <p>We will need docker or podman with minkube in order to run it. Although podman is supported it has experimental driver so i suggest we use docker for smoother transition and some less errors. When using docker there is not need to use hypervisor. lets start with configuration</p> start cluster with docker driverset docker driver as default <pre><code>minikube start --driver=docker\n</code></pre> <pre><code>minikube config set driver docker\nminikube start\n</code></pre> <p>either of command will be fine. if you use docker only then i suggest you use minikube config to set docker driver as always.</p> <ul> <li>Check the minikube node ip using <code>minikube IP</code>. Or you can ssh into it using <code>minikube ssh</code> \u2190 this will take you into minikube node</li> <li>Fire <code>minikube status</code> to check running status</li> <li>Hit <code>docker ps</code> after <code>minikube ssh</code> to check running containers and all services running in control plane</li> </ul> <p>Note</p> <p>minikube only create one node and it behaves as master and worker node</p> <p>Note</p> <p>For our convinience we will set shortcut to <code>minikube</code> as <code>mk</code>  1. open <code>.zshrc</code> or <code>.bashrc</code> in your favourite editor 2. type alias mk=\"minikube\"</p>"},{"location":"K8s/using-kubectl.html","title":"Using Kubectl command","text":"<p>Tip</p> <p>for simplicity add alias <code>kc</code>=<code>kubectl</code></p>"},{"location":"K8s/using-kubectl.html#simple-commands","title":"Simple commands","text":"<ul> <li><code>kc cluster-info</code> checks the cluster information by showing coredns, control planes information and ip address.</li> <li><code>kc get nodes</code> or <code>kc get no</code> displays the nodes.</li> <li><code>kc get namespaces</code> displays all namespaces in node.</li> <li>No pods have yet been generated in the default namespace. However, you can attempt <code>kc get po -n kubesystem</code>, which retrieves all pods in the kubsystem namespace.</li> <li><code>kc get po -n kubesystem -o wide</code> gives you more information such as ip address of each pod and nodes it associated with.</li> </ul>"},{"location":"K8s/using-kubectl.html#creating-pods","title":"Creating pods","text":"<ul> <li><code>kc run pod_name --image image_name</code> this command creates and runs pod and it will also automatically pulls image form dockerhub for us. ex <code>kc run nginx --image nginx</code> will create pod named nginx with image nginx. You can view using <code>kc get po -o wide nginx</code> command to check if pod is running or not.</li> <li>Describe the same pod using <code>kc describe po nginx</code>, It will show you details such as name, container, ip, namespace, label, node starttime, etc.</li> <li>Even though we deployed nginx pod but we can not access the port. Because we haven't created services necessary to access to exposed address.</li> <li>Now lets get some extra information about the pod<ul> <li>Fire <code>mk ssh</code></li> <li>Fire <code>docker ps --filter name=nginx</code></li> <li>You can see 2 pods &amp;rarr<ul> <li>1<sup>st</sup> is normal pod which is what we created</li> <li>2<sup>nd</sup> with <code>pause</code> keyword created by k8s to keep container namespace</li> <li>we shoudn't not touch the second pod type</li> </ul> </li> <li>Now go to container using <code>docker exec -it container_id sh</code><ul> <li>hit <code>cat /etc/hostname</code> which will show you hostname of pod</li> <li>hit <code>hostname -i</code> which will show you ip of pod and should be same as we saw in when we ran <code>describe</code> command</li> </ul> </li> <li>Finally fire <code>curl localhost</code> abd you should see welcome page of nginx</li> </ul> </li> <li>You can delete pod using <code>kc delete po nginx</code></li> </ul>"},{"location":"K8s/using-kubectl.html#managin-deployments","title":"Managin deployments","text":"<ul> <li>Create deployment using <code>kc deploy deployment-name --image deployment-image</code> which will also create neccessary pods in our case it's just one. ex <code>kc deply nginx-deployment --image nginx</code></li> <li>Describe same deployment using <code>kc describe deploy nginx-deployment</code>, you will get deployment details</li> <li>Use <code>kc scale deploy ngnix-deployment --replicas 5</code> to scale up the replicaset to 5, which essentially means it will include 5 pods. </li> <li>Scale deployment using provided quantities of replicas. Likewise, you can use the same command to scale down; but, this time, specify the number of less desired replicas, and it will scale down to that amount.</li> </ul> <p>Warning</p> <p>pod and deployment are different entities in k8s</p>"},{"location":"K8s/using-kubectl.html#managing-services","title":"Managing services","text":"<ul> <li>Even after we created the deployment, one of the client's pod connections will still fail. However, if you ssh into the node and attempt to connect to the pod's IP, you will succeed since pods' IPs are dynamic; hence, it isn't recommended to connect to them using an IP address to mitigate such a scenario. We will now create service to facilitate communication between pods and also client.</li> <li>Creating cluster ip<ul> <li>cluster ip are accessible in any cluster within the node.</li> <li>generally they are excellent choice for internal communication withini cluster as once ip is assigned is never chnages.</li> <li>use <code>kc expose deploy nginx-deployment --port 8080 --traget 80</code> to create cluster ip.</li> <li>it will also take care of load balancing for us.</li> <li>you can view clusterIP info using <code>kc get svc -o wide</code>. so you can fiddle with ip to communicate internally.</li> </ul> </li> <li>Creating node port<ul> <li>use command <code>kc expose deploy nginx-deployment --type NodePort --port 80</code> </li> <li>node port are accessible outside of cluster such our client</li> <li>port assigned to service url is of random</li> <li>to get the service url hit the command <code>mk service nginx-deployment --url</code></li> </ul> </li> <li>Creating load balancer using command <code>kc expose deploy nginx-deployment --type LoadBalancer --port 80</code>. there will be external IP which is pending in ase of minkube and &amp; will be assigned automatically in cloud. It is also accessible outside of cluster and can be accessed using localhost in our case.</li> </ul>"},{"location":"Linux/index.html","title":"Welcome to linux","text":"<p>This section contains knowledge about linux, terminals, howtos for installation</p>"},{"location":"Linux/awesome-commands.html","title":"Awesome commands","text":""},{"location":"Linux/awesome-commands.html#compression-and-archiving","title":"Compression and archiving","text":"<ul> <li><code>tar -cvf archive.tar foo bar dir/</code> \u2192 create new archive</li> <li><code>tar -xvf archive.tar</code> \u2192 extract tar archive</li> <li><code>tar -czvf archive.tar.gz file1 file2 dir/</code> \u2192 gzip compression with tar</li> <li><code>tar -xzvf archive.tar.gz</code> \u2192 gzip and tar extract </li> </ul>"},{"location":"Neovim/config.html","title":"Config","text":"<p>This is the complete tutorial to configure neovim to work with golang and some other language as IDE. we will explore some options and how neovim plugin system works as well lsp client and mason for installing our dependencies.  If you are really new to vim/neovim ecosystem I recommend you to get familier with neovim using <code>:Tutor</code> and you can also refer to awesome nvim kickstarter.</p>","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#how-to-proceed-with-configuration","title":"How to proceed with configuration","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#folder-structure","title":"Folder structure","text":"<ul> <li>Neovim looks for init.lua file in config dir ie. <code>${HOME}/.config/nvim</code></li> <li>Execute below set of commands to create neccessary file and Folder <pre><code>mkdir -p ${XDG_CONFIG_HOME}/nvim/lua/plugins\nmkdir -p ${XDG_CONFIG_HOME}/nvim/lua/custom\ntouch -p ${XDG_CONFIG_HOME}/nvim/init.lua\n\ncd ${XDG_CONFIG_HOME}/nvim/lua/plugins\ntouch autopairs.lua barbicue.lua cmp.lua colorscheme.lua comments.lua conform.lua dap.lua harpoon.lua highlight.lua lint.lua lsp.lua lualine.lua markdown.lua mini.lua noice.lua nvimtree.lua snapshot.lua telescope.lua treesitter.lua gopher.lua gitsigns.lua\n\ncd ${XDG_CONFIG_HOME}/nvim/lua\ntouch autocmds.lua keymaps.lua opts.lua \n\ncd ${XDG_CONFIG_HOME}/nvim/lua/custom\ntouch lsp.lua cmp.lua mason.lua\n</code></pre></li> <li>After completing above set of commands you see structure of your directory looks exactly like below <pre><code>\ue620 init.lua\n\uf115 lua\n\u251c\u2500\u2500 \ue620 autocmds.lua\n\u251c\u2500\u2500 \ue620 keymaps.lua\n\u251c\u2500\u2500 \ue620 opts.lua\n\u251c\u2500\u2500 \uf115 custom\n\u2502   \u251c\u2500\u2500 \ue620 cmp.lua\n\u2502   \u251c\u2500\u2500 \ue620 lsp.lua\n\u2502   \u2514\u2500\u2500 \ue620 mason.lua\n\u2514\u2500\u2500 \uf115 plugins\n    \u251c\u2500\u2500 \ue620 autopairs.lua\n    \u251c\u2500\u2500 \ue620 barbecue.lua\n    \u251c\u2500\u2500 \ue620 cmp.lua\n    \u251c\u2500\u2500 \ue620 colorscheme.lua\n    \u251c\u2500\u2500 \ue620 comments.lua\n    \u251c\u2500\u2500 \ue620 conform.lua\n    \u251c\u2500\u2500 \ue620 dap.lua\n    \u251c\u2500\u2500 \ue620 gitsigns.lua\n    \u251c\u2500\u2500 \ue620 gopher.lua\n    \u251c\u2500\u2500 \ue620 harpoon.lua\n    \u251c\u2500\u2500 \ue620 highlight.lua\n    \u251c\u2500\u2500 \ue620 lint.lua\n    \u251c\u2500\u2500 \ue620 lsp.lua\n    \u251c\u2500\u2500 \ue620 lualine.lua\n    \u251c\u2500\u2500 \ue620 markdown.lua\n    \u251c\u2500\u2500 \ue620 mini.lua\n    \u251c\u2500\u2500 \ue620 noice.lua\n    \u251c\u2500\u2500 \ue620 nvimtree.lua\n    \u251c\u2500\u2500 \ue620 snapshot.lua\n    \u251c\u2500\u2500 \ue620 telescope.lua\n    \u2514\u2500\u2500 \ue620 treesitter.lua\n</code></pre> <p>init.lua is special file which is looked up by neovim to find the configuration where custom folder is related to tidying configuration code. now plugins folder is where we are actually going to configure all of our plugins.</p> </li> </ul>","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#configuring-keymaps","title":"Configuring keymaps","text":"<ul> <li>To set keymap in neovim you can use vim api to do so <code>vim.keymap.set(mode, lhs, rhs, options)</code><ul> <li>mode \u2192 normal/visual/insert(n/v/i) any of this or all using lua table syntax <code>{\"i\", \"v\", \"n\"}</code></li> <li>lhs \u2192 whatever keys you want to set</li> <li>rhs \u2192 actual command, lua function or any other keymap you want to override</li> <li>options \u2192 accepts lua table generally you can provider buffer number and description but it's optional</li> </ul> </li> <li>Put eveything below in <code>lua/keymaps.lua</code> file. all keymaps are self explained by comments description field  <pre><code>vim.keymap.set(\"n\", \"&lt;Esc&gt;\", \"&lt;cmd&gt;nohlsearch&lt;CR&gt;\")\nvim.keymap.set(\"i\", \"jj\", \"&lt;Esc&gt;\")\nvim.keymap.set({ \"n\", \"i\" }, \"&lt;C-s&gt;\", \"&lt;cmd&gt;w&lt;cr&gt;\", { silent = true })\nvim.keymap.set({ \"n\", \"i\" }, \"&lt;C-c&gt;\", \"&lt;cmd&gt;bd!&lt;cr&gt;\", { silent = true })\n\n-- Diagnostic keymaps\nvim.keymap.set(\"n\", \"[d\", vim.diagnostic.goto_prev, { desc = \"Go to previous [D]iagnostic message\" })\nvim.keymap.set(\"n\", \"]d\", vim.diagnostic.goto_next, { desc = \"Go to next [D]iagnostic message\" })\nvim.keymap.set(\"n\", \"&lt;leader&gt;e\", vim.diagnostic.open_float, { desc = \"Show diagnostic [E]rror messages\" })\nvim.keymap.set(\"n\", \"&lt;leader&gt;q\", vim.diagnostic.setloclist, { desc = \"Open diagnostic [Q]uickfix list\" })\n\n-- Window navigations keymap\nvim.keymap.set(\"n\", \"&lt;C-h&gt;\", \"&lt;C-w&gt;&lt;C-h&gt;\", { desc = \"Move focus to the left window\" })\nvim.keymap.set(\"n\", \"&lt;C-l&gt;\", \"&lt;C-w&gt;&lt;C-l&gt;\", { desc = \"Move focus to the right window\" })\nvim.keymap.set(\"n\", \"&lt;C-j&gt;\", \"&lt;C-w&gt;&lt;C-j&gt;\", { desc = \"Move focus to the lower window\" })\nvim.keymap.set(\"n\", \"&lt;C-k&gt;\", \"&lt;C-w&gt;&lt;C-k&gt;\", { desc = \"Move focus to the upper window\" })\n\n-- Visual Mode yanking and pasting without delete result in it\nvim.keymap.set(\"v\", \"p\", '\"_dP', { desc = \"after yanking something it keeps in that register\" \n\n-- nvim tree binding\nvim.keymap.set(\"n\", \"&lt;leader&gt;ee\", \"&lt;Cmd&gt;NvimTreeToggle&lt;CR&gt;\", { desc = \"toggle nvim tree expolorer\" })\nvim.keymap.set(\n    \"n\",\n    \"&lt;leader&gt;ef\",\n    \"&lt;Cmd&gt;NvimTreeFindFile&lt;CR&gt;\",\n    { desc = \"open file focusing it and opening folder if neccessary\" }\n)\n\n-- todo comments toggle\nvim.keymap.set(\"n\", \"td\", \"&lt;Cmd&gt;TodoTelescope&lt;CR&gt;\", { desc = \"open todo in telescope\" })\nvim.keymap.set(\"n\", \"tdq\", \"&lt;Cmd&gt;TodoQuickFix&lt;CR&gt;\", { desc = \"open todo in quick fix list\" })\n\n-- quickfix list navigation\nvim.keymap.set(\"n\", \"&lt;C-n&gt;\", \"&lt;Cmd&gt;cnext&lt;CR&gt;\", { desc = \"navigate forward in quickfix\" })\nvim.keymap.set(\"n\", \"&lt;C-p&gt;\", \"&lt;Cmd&gt;cprev&lt;CR&gt;\", { desc = \"navigate backward in quickfix\" })\n\n-- stay in indent mode in Visual\nvim.keymap.set(\"v\", \"&lt;\", \"&lt;gv\", { desc = \"indent prev keeping in visual mode\" })\nvim.keymap.set(\"v\", \"&gt;\", \"&gt;gv\", { desc = \"indent next keeping in visual mode\" })\n\n-- move test up or down in visual mode\nvim.keymap.set(\"v\", \"&lt;A-j&gt;\", \":m '&gt;+1&lt;CR&gt;gv=gv\", { desc = \"indent next keeping in visual mode\" })\nvim.keymap.set(\"v\", \"&lt;A-k&gt;\", \":m '&lt;-2&lt;CR&gt;gv=gv\", { desc = \"indent next keeping in visual mode\" })\n\n-- snapshots\nvim.keymap.set(\"v\", \"&lt;leader&gt;cs\", function()\n    require(\"nvim-silicon\").clip()\nend, { desc = \"copy screenshot to clipboard\", silent = true })\nvim.keymap.set(\"v\", \"&lt;leader&gt;cc\", function()\n    require(\"nvim-silicon\").file()\nend, { desc = \"save screenshot as file\", silent = true })\n</code></pre></li> </ul>","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#configuring-options","title":"Configuring options","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#adding-autocommands","title":"Adding autocommands","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#adding-filetypes","title":"Adding filetypes","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#initaiting-lazy-loader","title":"Initaiting lazy loader","text":"<p>lazy is plugin used to install other plugins in neovim it's like you have to use <code>nvim autocmd</code> in order to load lazy plugin at startup. follow along with below code and you will know</p> <pre><code>local lazypath = vim.fn.stdpath 'data' .. '/lazy/lazy.nvim'\nif not vim.loop.fs_stat(lazypath) then\n  local lazyrepo = 'https://github.com/folke/lazy.nvim.git'\n  vim.fn.system { 'git', 'clone', '--filter=blob:none', '--branch=stable', lazyrepo, lazypath }\nend \nvim.opt.rtp:prepend(lazypath)\n</code></pre> <ol> <li>line 1 \u2192 sets lazypath for lazy plugins to be loaded or searched</li> <li>line 2 \u2192 checks if lazy plugin is present at path given if not then proceed</li> <li>line 3&amp;4 \u2192 clone the lazyrepo using vim system function on given std path</li> <li>line 6 \u2192 <code>opt.rtp:prepend(lazypath)</code> means initiate directory path for searching neovim runtime files</li> </ol>","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#configuring-statusline-using-lualine","title":"configuring statusline using lualine","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#configuring-file-explorer-using-nvim-tree","title":"configuring file explorer using nvim-tree","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#adding-theme-and-colorscheme","title":"adding theme and colorscheme","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#adding-syntax-highlight-with-nvim-treesitter","title":"adding syntax highlight with nvim-treesitter","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#setting-up-formatter-using-conform","title":"setting up formatter using conform","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#setting-up-autocompletion-using-nvim-cmp","title":"setting up autocompletion using nvim-cmp","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#setting-up-lsp-using-lspconfig","title":"setting up lsp using lspconfig","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#setting-up-linter-using-nvim-lint","title":"setting up linter using nvim-lint","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Neovim/config.html#setting-up-debugging-using-nvim-dap","title":"setting up debugging using nvim-dap","text":"","tags":["golang","ide","neovim","lsp"]},{"location":"Python/index.html","title":"Welcome to python","text":"<p>This section contains knowledge base for python</p>"}]}